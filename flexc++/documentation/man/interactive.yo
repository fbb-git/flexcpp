manpagesection(1. INTERACTIVE SCANNERS)

An interactive scanner is characterized by the fact that scanning is postponed
until an end-of-line character has been received, followed by reading all
information on the line, read so far. Flc() supports the 
tt(%interactive) directive), generating an
interactive scanner. Here it is assumed that tt(Scanner) is the name of the
scanner class generated by flc().

bf(Caveat:) generating interactive and non-interactive scanners should not be
mixed as their class organizations fundamentally differ, and several of the
Scanner class's members are only available in the non-interactive scanner. As
the tt(Scanner.h) file contains the Scanner class's interface, which is
normally left untouched by flc(), flc() cannot adapt the Scanner class when
requested to change the interactivity of an existing Scanner class. Because of
this support for the tt(--interactive) option was discontinued at flc()'s
1.01.00 release.

The interactive scanner generated by flc() has the following characteristics:
    itemization(
    it() The tt(Scanner) class is derived privately from
        tt(std::istringstream) and (as usual) publicly from tt(ScannerBase).
    it() The tt(istringstream) base class is constructed by its default
        constructor. 
    it() The function tt(lex)'s default implementation is removed from
        tt(Scanner.h) and is implemented in the generated tt(lex.cc) source
        file. It performs the following tasks:

        - If the token returned by the scanner is not equal to 0 it is
            returned as then next token;

        - Otherwise the next line is retrieved from the input stream
            passed to the tt(Scanner)'s constructor (by default tt(std::cin)).
            If this fails, 0 is returned.

        - A tt('\n') character is appended to the just read line, and the
            scanner's tt(std::istringstream) base class object is
            re-initialized with that line;

        - The member tt(lex_) returns the next token.
    )
    This implementation allows code calling tt(Scanner::lex()) to conclude, as
usual, that the input is exhausted when tt(lex) returns 0.

Here is an example of how such a scanner could be used:
    itemization(
        verb(
    // scanner generated using 'flexc++ lexer' with lexer containing 
    // the %interactive directive
    int main()
    {
        Scanner scanner;        // by default: read from std::cin 
    
        while (true)
        {
            cout << "? ";       // prompt at each line

            while (true)        // process all the line's tokens
            {
                int token = scanner.lex();
    
                if (token == '\n')  // end of line: new prompt
                    break;
    
                if (token == 0)     // end of input: done
                    return 0;
    
                                    // process other tokens
                cout << scanner.matched() << '\n';
                if (scanner.matched()[0] == 'q')
                    return 0;
            }
        }
    }
        )
    )

