    manpagesection(1. QUICK START)

    A bare-bones, no-frills scanner is generated as follows:

    itemization(
    it() Create a file tt(lexer) defining the regular expressions to
recognize, and the tokens to return. Use token values exceeding 0xff if plain
ascii character values can also be used as token values. Example (assume
capitalized words are token-symbols defined in an enum defined by the scanner
class):
        verb(
%%
[ \t\n]+                            // skip white space chars.
[0-9]+                              return NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return IDENTIFIER;
.                                   return matched()[0];
        )

    it() Execute:
        verb(
    flexc++ lexer
        )
    This generates four files):tt(Scanner.h, Scanner.ih, Scannerbase.h), and
tt(lex.cc) 

    it() Edit tt(Scanner.h), add the enum defining the token-symbols in
(usually) the public section of the class tt(Scanner). E.g.,
        verb(
class Scanner: public ScannerBase
{
    public:
        enum Tokens
        {
            IDENTIFIER = 0x100,
            NUMBER
        };
    // ... (etc, as generated by flexc++)
        )

    it() Create a file defining tt(int main), e.g.:
        verb(
#include <iostream>
#include "Scanner.h"

using namespace std;

int main()
{
    Scanner scanner;        // define a Scanner object

    while (int token = scanner.lex())   // get all tokens
    {
        string const &text = scanner.matched();
        switch (token)
        {
            case Scanner::IDENTIFIER:
                cout << "identifier: " << text << '\n';
            break;

            case Scanner::NUMBER:
                cout << "number: " << text << '\n';
            break;

            default:
                cout << "char. token: `" << text << "'\n";
            break;
        }
    }
}
        )
    it() Compile all tt(.cc) files:
        verb(
    g++ --std=c++11 *.cc
        )
    
    it() To `tokenize' tt(main.cc), execute:
        verb(
    a.out < main.cc
        )
    )

    manpagesection(2. QUICK START: FLEXC++ and BISONC++)

To interface flc() to the bf(bisonc++)(1) parser generator proceed as follows:
    itemization(
    it() Specify a grammar that can be processed by bf(bisonc++)(1). Assuming
that the scanner and parser are developed in, respectively, the
sub-directories tt(scanner) and tt(parser), then a simple grammar
specification that can be used with the scanner developed in the previous
section is, e.g., write the file tt(parser/grammar):
        verb(
%scanner                ../scanner/Scanner.h
%scanner-token-function d_scanner.lex()

%token IDENTIFIER NUMBER CHAR

%%

startrule:
    startrule tokenshow
|
    tokenshow
;

tokenshow:
    token
    {
        std::cout << "matched: " << d_scanner.matched() << '\n';
    }
;

token:
    IDENTIFIER
|
    NUMBER
|
    CHAR
;
    )
    it() Write a scanner specification file. E.g.,
    verb(
%%

[ \t\n]+                            // skip white space chars.
[0-9]+                              return Parser::NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return Parser::IDENTIFIER;
.                                   return Parser::CHAR;
    )
    This causes the scanner to  return tt(Parser) tokens to the generated
parser. 

    it() Add the line
    verb(
#include "../parser/Parserbase.h"
    )
    to the file tt(scanner/Scanner.ih)

    it() Write a simple tt(main) function in the file tt(main.cc). E.g.,
    verb(
#include "parser/Parser.h"

int main(int argc, char **argv)
{
    Parser parser;

    parser.parse();
}
    )
    
    it() Generate a scanner in the tt(scanner) subdirectory:
    verb(
flexc++ lexer
    )
    
    it() Generate a parser in the tt(parser) subdirectory:
    verb(
bisonc++ grammar
    )
    
    it() Compile all sources:
    verb(
g++ --std=c++0x *.cc */*.cc
    )

    it() Execute the program, providing it some source file to be processed:
    verb(
a.out < main.cc
    )
        )

    manpagesection(3. GENERATED FILES)

Flc() generates four files from a well-formed input file:
    itemization(

    it() A file containing the implementation of the tt(lex) member function
and its support functions. By default this file is named tt(lex.cc).

    it() A file containing the scanner's class interface. By default this file
is named tt(Scanner.h). The scanner class itself is generated once and is
thereafter `owned' by the programmer, who may change it em(ad-lib). Newly
added members (data members, function members) will survive future flc() runs
as flc() will never rewrite an existing scanner class interface file, unless
explicitly ordered to do so. 

    it() A file containing the interface of the scanner class's em(base
class). The scanner class is publicly derived from this base class. It is used
to minimize the size of the scanner interface itself. The scanner base class
is `owned' by bf(flexc++) and should never be hand-modified. By
default the scanner's base class is provided in the file
tt(Scannerbase.h). At each new flc() run this file is rewritten unless flc()
is explicitly ordered em(not) to do so.

    it() A file containing the em(implementation header). This file should
contain includes and declarations that are only required when compiling the
members of the scanner class. By default this file is named
tt(Scanner.ih). This file, like the file containing the scanner class's
interface is never rewritten by flc() unless flc() is explicitly ordered to do
so.
    )

manpagesection(4. OPTIONS)

    includefile(../manual/intro/options)
