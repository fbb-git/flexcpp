Code is generated by an object of the class tt(Generator).  The generator
generates the following files (using default names, all defaults can be
overruled by directives and options):

itemization(
itt(Scannerbase.h.) This file defines the scanner's base class. It is always
rewritten and declares data members used by the scanner.

itt(Scanner.h.) This file represents the generated scanner's interface. It
inherits from tt(ScannerBase) and is written only if not existing. 

itt(Scanner.ih.) This file represents the generated scanner's em(internal
header file). The internal header file is part of a design philosophy
according to which all source files belonging to a class should merely include
the internal header file, which declares all headers and other elements that
are required for the correct compilation of the class's source files.

itt(lex.cc) This file contains the implementation of the scanner function and
any support functions it may need. This file is always rewritten.
)

Each of these files has a skeleton, found in tt(/usr/share/flexc++) (the
development header files are in the tt(skeletons/) subdirectory of the source
package). The skeletons are the templates (molds) from which the files
matching the requirements as defined in flc()'s input file(s) are created:
    itemization( 
    it() em(Static data) are inserted into the generated tt(lex.cc) file;
    it() em(Actions) are inserted into the generated tt(lex.cc);
    it() em(Declarations) are inserted into the generated tt(Scannerbase.h)
        file. 
    )
    The member tt(genLex) generates the lexer file tt(lex.cc). It recognizes
tt($insert) lines starting in column 1 and performs the matching action,
inserting appropriate elements into the generated file.

Other generating members act similarly:

The member tt(genBase) generates the scanner base file tt(Scannerbase.h), the
member tt(genScanner) generates tt(Scanner.h).

The code generated by tt(flexc++) must read input, match the input with some
regular expressin and return the associated token. A catch-all escape is
provided by the implicitly provided rule echoing all non-matched input to the
standard output stream.

The generated code consists of these parts:
    itemization(
    it() The character-table (actually: range-table). See section
        ref(RANGETAB). 

    it() The DFAs are generated by tt(Generator::dfas). 
    )

    For each of the DFAs the function tt(Generator::dfa) is called. 

    The function tt(Generator::dfa) receives as its first argument a
tt(DFAs::Pair) (see figure ref(DFASFIG)), containing the name of the
start condition that is associated with the DFA and the DFA itself.
The function performs the following tasks:
    itemization(
    it() The name of the current start condition is stored in
        tt(startStates) (to allow checking for repetitive handling);
    it() The row number of the first row of the current DFA in tt(s_dfa)
        is saved in the vector tt(dfaOffsets);
    it() tt(Generator::dfaRow) is called for each row of the DFA (see figure
        ref(DFAROWFIG)). This latter function writes the vector of DFA rows to
        transit to (i.e., rows relative to the current DFA's start row, so not
        the actual rows in tt(s_dfa)) for each of the character ranges
        (calling tt(Generator::dfaTransitions)), followed by the number of the
        rule that is matched if the rule represents a final state not
        necessarily at BOL and the number of the rule that is matched if the
        rule represents a final state at BOL. Values -1 are used if no such
        rules exist for the state represented by the current row.  
    )

    The function tt(Generator::declarations) adds the declarations of
tt((*d_dfaBase_)[], s_dfa_[][], s_dfaBase_[][]) etc. to tt(ScannerBase.h),
providing these declarations with their required (higher order) dimension
values. 

    The function tt(Generator::actions) inserts the actions in the function
tt(ScannerBase::executeAction_), implemented in tt(lex.cc). Actions are
inserted separately for each tt(RuleType) that was used. Each tt(NORMAL,
LOP_1, LOP_4) and tt(LOP_FIXED) (fixed-tail LOP rule) type of rule has its own
action block, and their action blocks are inserted first. tt(LOP_2) and
tt(LOP_3) actions are all identical, and flc() creates a set of fall-through
case labels for these actions. 










