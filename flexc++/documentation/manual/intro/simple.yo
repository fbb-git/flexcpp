The following lexer file detects identifiers:

verbinclude(demos/simplelexer)

The tt(main()) function below defines a Scanner object, and calls tt(lex()) as
long as it does not return 0.  tt(lex()) returns 0 if the end of the input
stream is reached. (By default tt(std::cin) will be used).

verbinclude(demos/mainforsimplelexer.cc)

Each identifier on the input stream is replaced by itself and some surrounding
text. By default, flc() echoes all characters it cannot match to tt(cout). If
you do not want this, simply use the following pattern:

verbinclude(demos/simpleignoringlexer)

The second pattern will cause flc() to ignore all characters on the input
stream. The first pattern will still match all identifiers, even those that
consist of only one letter.  But everything else is ignored. The second
pattern has no associated action, and that is precisely what happens in lex:
nothing. The stream is simply scanned for more characters.

It is also possible to let the generated lexer do all the work.  The simple
lexer below shows all encountered identifiers.

verbinclude(demos/simpleoutputtinglexer)

Note how a compound statement may be used instead of a one line statement at
the end of the line. The opening bracket must appear on the same line as the
pattern, however. Also note that inside an action, we can use tt(Scanner)'s
members. E.g., tt(matched()) contains the text of the token that was last
matched.  The following tt(main) function can be used to activate the
generated scanner.

verbinclude(demos/mainforoutputtinglexer.cc)

Note how simple this function is. tt(Scanner::lex()) does not
return until the entire input stream has been processed, because none of
the patterns has an associated action using a return statement.





