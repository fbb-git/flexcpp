// Generated by Flexc++ V0.8.3 on Mon, 16 Jan 2012 21:44:26 +0100

#ifndef Scanner_H_INCLUDED_
#define Scanner_H_INCLUDED_

// $insert baseclass_h
#include "scannerbase.h"

#include <stack>
#include <unordered_map>

class Scanner: public ScannerBase
{
    bool d_inBlock = false;     // when in-block return ' ' on blanks
    std::string d_patternName;
    std::unordered_map<std::string, std::string> d_nameExpansion;

    // declared below:
    // SCStack d_scStack;

    public:
        explicit Scanner(std::istream &in = std::cin, 
                    std::ostream &out = std::cout);
        
        Scanner(std::string const &infile, std::string const &outfile);

        // $insert lexFunctionDecl
        int lex();
        void pushEOLN();            // next token to return: '\n'
        void newDefinition();       // new named regex, 'line' miniscanner
                                    
        void addDefinition(std::string const &name, 
                           std::string const &definition);

        void blockEnds();

    private:
        void switchToINITIAL();
        using ScannerBase::push;

        void push(StartCondition_ sc); // push and revert to sc
        int popSc(int token = 0);   // revert to the pushed StartCondition,
                                    // returning 'token'

            // the start-condition stack can only be used from push and popSC
        class SCStack: private std::stack<StartCondition_> 
        {
            friend void Scanner::push(StartCondition_ sc);
            friend int Scanner::popSc(int token);
        } d_scStack;
    
        int block();        // recognize a block-begin, returning BLOCK
        void maybeSwitchStream();
        bool popStream();           // hides ScannerBase::popStream from
                                    // lex.cc 
        void setLineTags(std::string const &filename) const;
        void pushNameExpansion();

        int lex_();
        int executeAction_(size_t ruleNr);

        void preCode();     // re-implement this function for code that must 
                            // be exec'ed before the patternmatching starts
};

inline void Scanner::blockEnds() 
{
    d_inBlock = false;
}

inline void Scanner::pushEOLN() 
{
    push('\n');
}

inline void Scanner::preCode() 
{
    // optionally replace by your own code
}

//inline Scanner::Scanner(std::string const &infile, std::string const &outfile)
//:
//    ScannerBase(infile, outfile)
//{}

// $insert inlineLexFunction
inline int Scanner::lex()
{
    return lex_();
}


#endif // Scanner_H_INCLUDED_

