<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> Flexc++ (Version 2.06.03) User Guide </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr>
<ul>
    <li> <a href="flexc++.html">Table of Contents</a>
    <li> <a href="flexc++02.html">Next Chapter</a>
</ul>
<hr>
<a name="Introduction"></a><a name="l1"></a>
<h1 >Chapter 1: Introduction</h1>
<p>
This manual describes <strong >flexc++</strong>, a tool for generating lexical scanners:
programs recognizing patterns in text. Usually, scanners are used in
combination with parsers which can be generated by, e.g.,
<a href="https://fbb-git.github.io/bisoncpp/">bisonc++</a>.
<p>
<strong >Flexc++</strong> reads one or more <em >input files</em> (called `lexer' in this manual),
containing rules: regular expressions, optionally associated with <strong >C++</strong>
code. From this <strong >Flexc++</strong> generates several files, containing the declaration and
implementation of a class (<code >Scanner</code> by default). The member function
<code >lex</code> is used to analyze input: it looks for text matching the regular
expressions. Whenever it finds a match, it executes the associated <strong >C++</strong>
code.
<p>
<strong >Flexc++</strong> is highly comparable to the programs flex and flex++, written by Vern
Paxson. Our goal was to create a similar program, completely implementing it
in <strong >C++</strong>, and merely generating <strong >C++</strong> code. Most flex / flex++ grammars should
be usable with <strong >flexc++</strong>, with minor adjustments (see also `<a href="flexc++02.html#differences">differences
with flex/flex++ 2</a>').
<p>
This edition of the manual documents version 2.06.03 and provides detailed
information on <strong >flexc++</strong>'s use and inner workings. Some texts are adapted from the
<a href="http://flex.sourceforge.net/manual/index.html">flex manual</a>.  The manual
page <strong >flexc++</strong>(1) provides an overview of the command line options and
option directives, <strong >flexc++api</strong>(3) provides an overview of the application
programmer's interface, and <strong >flexc++input</strong>(7) describes the organization of
<strong >flexc++</strong>'s input <strong >s</strong>.
<p>
The most recent version of both this manual and <strong >flexc++</strong> itself can be found at
<a href="https://fbb-git.github.io/flexcpp/">https://fbb-git.github.io/flexcpp/</a>. If you find a bug in <strong >flexc++</strong> or
mistakes in the documentation, please report it to the authors.
<p>
<strong >Flexc++</strong> was designed and written by Frank B. Brokken, Jean-Paul van Oosten, and
(up to version 0.5.3) Richard Berendsen.
<p>
<a name="l2"></a>
<h2 >1.1: Running Flexc++</h2>
        <strong >Flexc++</strong>(1) was designed after <strong >flex</strong>(1) and <strong >flex++</strong>(1). Like these
latter two programs <strong >flexc++</strong> generates code performing pattern-matching on text,
possibly executing actions when the input matches its <em >regular expressions</em>.
<p>
Contrary to <strong >flex</strong> and <strong >flex++</strong>, <strong >flexc++</strong> generates code that is
explicitly intended for use by <strong >C++</strong> programs. The well-known <strong >flex</strong>(1)
program generates <strong >C</strong> source-code and <strong >flex++</strong>(1) merely offers a
<strong >C++</strong>-like shell around the <code >yylex</code> function generated by <strong >flex</strong>(1) and
hardly supports present-day ideas about <strong >C++</strong> software design.
<p>
<strong >Flexc++</strong> creates a <strong >C++</strong> class offering a predefined member function
<strong >lex</strong> which matches input against regular expressions and possibly executes
<strong >C++</strong> code once regular expressions are matched. The code generated by
<strong >flexc++</strong> is pure <strong >C++</strong>, allowing its users to apply all of the features
offered by that language.
<p>
<strong >Flexc++</strong>'s synopsis is:
    <blockquote >
        <strong >flexc++</strong> [OPTIONS] <code >rules-file</code>
    </blockquote>
    Its options are covered in section <a href="flexc++01.html#OPTIONS">1.1.1</a>, the format of its
rules-file is discussed in chapter <a href="flexc++03.html#FILEFORMAT">3</a>.
<p>
<a name="OPTIONS"></a><a name="l3"></a>
<h3 >1.1.1: Flexc++ options</h3>
            Where available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.  Options
affecting the class header or implementation header file are ignored if these
files already exist. Options accepting a `filename' do not accept path names,
i.e., they cannot contain directory separators (<code >/</code>); options accepting a
'pathname' may contain directory separators.
<p>
Some options may generate errors. This happens when an option conflicts with
the contents of an existing file which <strong >flexc++</strong> cannot modify (e.g., a scanner
class header file exists, but doesn't define a name space, but a
<code >--namespace</code> option was provided). To solve the error the offending option
could be omitted, the existing file could be removed, or the existing file
could be hand-edited according to the option's specification. Note that <strong >flexc++</strong>
currently does not handle the opposite error condition: if a previously used
option is omitted, then <strong >flexc++</strong> does not detect the inconsistency. In those
cases you may encounter compilation errors.
<p>
<ul>
    <li> <strong >--baseclass-header</strong>=<code >filename</code> (<strong >-b</strong>)<br/>
          Use <code >filename</code> as the name of the file to contain the scanner
           class's base class. Defaults to the name of the scanner class plus
           <code >base.h</code>
<p>
It is an error if this option is used and an already
            existing scanner-class header file does not include
            <code >`filename'</code>. 
<p>
<li> <strong >--baseclass-skeleton</strong>=<code >pathname</code> (<strong >-C</strong>)<br/> 
           Use <code >pathname</code> as the path to the file containing the skeleton of
            the scanner class's base class. Its filename defaults to
            <code >flexc++base.h</code>.
<p>
<li> <strong >--case-insensitive</strong><br/>
           Use this option to generate a scanner <em >case insensitively</em>
            matching regular expressions. All regular expressions specified in
            <strong >flexc++</strong>'s input file are interpreted case insensitively and the
            resulting scanner object will case insensitively interpret its
            input. 
<p>
When this option is specified the resulting scanner does not
            distinguish between the following rules:
           <pre>

        First       // initial F is transformed to f
        first
        FIRST       // all capitals are transformed to lower case chars
                
</pre>

           With a case-insensitive scanner only the first rule can be matched,
            and <strong >flexc++</strong> will issue warnings for the second and third rule about
            rules that cannot be matched.
<p>
Input processed by a case-insensitive scanner is also handled case
            insensitively. The above mentioned <code >First</code> rule is matched for
            all of the following input words: <code >first First FIRST firST</code>. 
<p>
Although the matching process proceeds case insensitively, the
            matched text (as returned by the scanner's <code >matched()</code> member)
            always contains the original, unmodified text. So, with the above
            input <code >matched()</code> returns, respectively <code >first, First, FIRST</code>
            and <code >firST</code>, while matching the rule <code >First</code>.
<p>
<li> <strong >--class-header</strong>=<code >filename</code> (<strong >-c</strong>)<br/>
           Use <code >filename</code> as the name of the file to contain the scanner
            class. Defaults to the name of the scanner class plus the suffix
            <code >.h</code>
<p>
<li> <strong >--class-name</strong>=<code >className</code><br/>
           Use <code >className</code> (rather than <code >Scanner</code>) as the name of the
            scanner class. Unless overridden by other options generated files
            will be given the (transformed to lower case) <code >className*</code> name
            instead of <code >scanner</code>*.
<p>
It is an error if this option is used and an already
            existing scanner-class header file does not define <code >class
            `className'</code>
<p>
<li> <strong >--class-skeleton</strong>=<code >pathname</code> (<strong >-C</strong>)<br/>
           Use <code >pathname</code> as the path to the file containing the skeleton of
            the scanner class. Its filename defaults to <code >flexc++.h</code>.
<p>
<li> <strong >--construction</strong> (<strong >-K</strong>)<br/>
           Write details about the lexical scanner to the file
            <code >`rules-file'.output</code>. Details cover the used character ranges,
            information about the regexes, the raw NFA states, and the final
            DFAs.
<p>
<li> <strong >--debug</strong> (<strong >-d</strong>)<br/> 
           Provide <code >lex</code> and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the <code >setDebug(bool
            on-off)</code> member. Note that <code >#ifdef DEBUG</code> macros are not used
            anymore. By rerunning <strong >flexc++</strong> without the <strong >--debug</strong> option an
            equivalent scanner is generated not containing the debugging
            code. This option does not provide debug information about <strong >flexc++</strong>
            itself. For that use the options <code >--own-parser</code> and/or
            <code >--own-tokens</code> (see below). 
<p>
<li> <strong >--filenames</strong>=<code >genericName</code> (<strong >-f</strong>)<br/>
           Generic name of generated files (header files, not the
            <code >lex</code>-function source file, see the <code >--lex-source</code> option for
            that). By default the header file names will be equal to the name
            of the generated class.
<p>
<li> <strong >--help</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--implementation-header</strong>=<code >filename</code> (<strong >-i</strong>)<br/> 
           Use <code >filename</code> as the name of the file to contain the
            implementation header. Defaults to the name of the generated
            scanner class plus the suffix <code >.hh</code>. The implementation header
            should contain all directives and declarations <em >only</em> used by
            the implementations of the scanner's member functions. It is the
            only header file that is included by the source file containing
            <strong >lex()</strong>'s implementation.  User defined implementation of other
            class members may use the same convention, thus concentrating all
            directives and declarations that are required for the compilation
            of other source files belonging to the scanner class in one header
            file.
<p>
It is an error if this option is used and an already
            <code >'filename'</code> file does not include the scanner class header
            file.
<p>
<li> <strong >--implementation-skeleton</strong>=<code >pathname</code> (<strong >-I</strong>)<br/>
           Use <code >pathname</code> as the path to the file containing the skeleton of
            the implementation header. Its filename defaults to
            <code >flexc++.hh</code>.
<p>
<li> <strong >--lex-skeleton</strong>=<code >pathname</code> (<strong >-L</strong>)<br/>
           Use <code >pathname</code> as the path to the file containing the
            <code >lex()</code> member function's skeleton. Its filename defaults to
            <code >flexc++.cc</code>.
<p>
<li> <strong >--lex-function-name</strong>=<code >funname</code><br/>
           Use <code >funname</code> rather than <code >lex</code> as the name of the member
            function performing the lexical scanning.
<p>
<li> <strong >--lex-source</strong>=<code >filename</code> (<strong >-l</strong>)<br/>
           Define <code >filename</code> as the name of the source file to contain the
            scanner member function <code >lex</code>. Defaults to <code >lex.cc</code>.
<p>
<li> <strong >--matched-rules</strong> (<strong >-'R'</strong>)<br/>
           The generated scanner will write the numbers of matched rules to 
            the standard output. It is implied by the <code >--debug</code> option.
            Displaying the matched rules can be suppressed by calling the
            generated  scanner's member <code >setDebug(false)</code> (or, of course, by
            re-generating the scanner without using specifying 
            <code >--matched-rules</code>).
<p>
<li> <strong >--max-depth</strong>=<code >depth</code> (<strong >-m</strong>)<br/>
           Set the maximum inclusion depth of the lexical scanner's
            specification files to <code >depth</code>. By default the maximum depth is
            set to 10. When more than <code >depth</code> specification files are used
            the scanner throws a <code >Max stream stack size exceeded</code>
            <code >std::length_error</code> exception. 
<p>
<li> <strong >--namespace</strong>=<code >identifier</code> <br/>
           Define the scanner class in the namespace <code >identifier</code>. By default
            no namespace is used. If this options is used the
            implementation header is provided with a commented out <code >using
            namespace</code> declaration for the requested namespace.  In addition,
            the scanner and scanner base class header files also use the 
            specified namespace to define their include guard directives.
<p>
It is an error if this option is used and an already
            scanner-class header file does not define <code >namespace
            identifier</code>. 
<p>
<li> <strong >--no-baseclass-header</strong><br/>
           Do not write the file containing the scanner's base class interface
            even if it doesn't yet exist. By default the file containing the
            scanner's base class interface is (re)written each time <strong >flexc++</strong> is
            called.
<p>
<li> <strong >--no-lines</strong><br/> 
           Do not put <strong >#line</strong> preprocessor directives in the file containing
            the scanner's <code >lex</code> function. By default <code >#line</code> directives
            are entered at the beginning of the action statements in the
            generated <code >lex.cc</code> file, allowing the compiler and debuggers
            to associate errors with lines in your grammar specification
            file, rather than with the source file containing the <code >lex</code>
            function itself.
<p>
<li> <strong >--no-lex-source</strong><br/>
           Do not write the file containing the scanner's predefined scanner
            member functions, even if that file doesn't yet exist. By default
            the file containing the scanner's <code >lex</code> member function is
            (re)written each time <strong >flexc++</strong> is called. This option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
<p>
<li> <strong >--own-parser</strong> (<strong >-P</strong>)<br/> 
           The actions performed by <strong >flexc++</strong>'s own parser are written to the
            standard output stream.
<p>
This option does <em >not</em> result in the generated program optionally
            displaying the actions of its <code >lex</code> function. If that is what
            you want, use the <code >--debug</code> option.
<p>
<li> <strong >--own-tokens</strong> (<strong >-T</strong>)<br/> 
           The tokens returned as well as the text matched by <strong >flexc++</strong> are
            written to the standard output stream when this option is used.
<p>
This option does <em >not</em> result in the generated program displaying
            returned tokens and matched text. If that is what you want, use
            the <code >--print-tokens</code> option.
<p>
<li> <strong >--print-tokens</strong> (<strong >-t</strong>)<br/> 
           The tokens returned as well as the text matched by the
            <em >generated</em> <code >lex</code> function are displayed on the standard
            output stream, just before returning the token to <code >lex</code>'s
            caller. Displaying tokens and matched text is suppressed again
            when the <code >lex.cc</code> file is generated without using this
            option. The function showing the tokens (<code >ScannerBase::print__</code>)
            is called from <code >Scanner::printTokens</code>, which is defined in-line
            in <code >Scanner.h</code>. Calling <code >ScannerBase::print__</code>, therefore, can
            also easily be controlled by an option controlled by the program
            using the scanner object.
<p>
This option does <em >not</em> show the tokens returned and text matched
            by <strong >flexc++</strong> itself when reading its input <strong >s</strong>. If that is what
            you want, use the <code >--own-tokens</code> option.
<p>
<li> <strong >--regex-calls</strong><br/> 
           Show the function call order when parsing regular expressions (this
            option is normally not required. Its main purpose is to help
            developers understand what happens when regular expressions are
            parsed).
<p>
<li> <strong >--show-filenames</strong> (<strong >-F</strong>)<br/> 
           Write the names of the files that are generated to the 
            standard error stream.
<p>
<li> <strong >--skeleton-directory</strong>=<code >pathname</code> (<strong >-S</strong>)<br/> 
           Defines the directory containing the skeleton files. This option
            can be overridden by the specific skeleton-specifying options
            (<code >-B -C, -H,</code> and <code >-I</code>).
<p>
<li> <strong >--target-directory</strong>=<code >pathname</code> <br/> 
           Specifies the directory where generated files should be written.
            By default this is the directory where <strong >flexc++</strong> is called.
<p>
<li> <strong >--usage</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--verbose</strong>(<strong >-V</strong>)<br/> 
           The verbose option generates on the standard output stream various
            pieces of additional information, not covered by the
            <code >--construction</code> and <code >--show-filenames</code> options.
<p>
<li> <strong >--version</strong> (<strong >-v</strong>)<br/>
            Display <strong >flexc++</strong>'s version number and terminate.
    </ul>
<p>
<a name="simpleexamples"></a><a name="l4"></a>
<h2 >1.2: Some simple examples</h2>
<p>
<a name="lexermain"></a><a name="l5"></a>
<h3 >1.2.1: A simple lexer file and main function</h3>
        The following lexer file detects identifiers:
<p>
<pre >
%%
[_a-zA-Z][_a-zA-Z0-9]* return 1;
</pre>

<p>
The <code >main()</code> function below defines a Scanner object, and calls <code >lex()</code> as
long as it does not return 0.  <code >lex()</code> returns 0 if the end of the input
stream is reached. (By default <code >std::cin</code> will be used).
<p>
<pre >
#include &lt;iostream&gt;
#include "Scanner.h"

using namespace std;

int main()
{
	Scanner scanner;
	while (scanner.lex())
		cout &lt;&lt; "[Identifier: " &lt;&lt; scanner.matched() &lt;&lt; "]";
}
</pre>

<p>
Each identifier on the input stream is replaced by itself and some surrounding
text. By default, <strong >flexc++</strong> echoes all characters it cannot match to <code >cout</code>. If
you do not want this, simply use the following pattern:
<p>
<pre >
%%
[_a-zA-Z][_a-zA-Z0-9]*		return 1;
.|\n						// ignore
</pre>

<p>
The second pattern will cause <strong >flexc++</strong> to ignore all characters on the input
stream. The first pattern will still match all identifiers, even those that
consist of only one letter.  But everything else is ignored. The second
pattern has no associated action, and that is precisely what happens in lex:
nothing. The stream is simply scanned for more characters.
<p>
It is also possible to let the generated lexer do all the work.  The simple
lexer below shows all encountered identifiers.
<p>
<pre >
%%
[_a-zA-Z][_a-zA-Z0-9]*      {
            std::cout &lt;&lt; "[Identifier: " &lt;&lt; matched() &lt;&lt; "]\n";
        }
.|\n                        // ignore
</pre>

<p>
Note how a compound statement may be used instead of a one line statement at
the end of the line. The opening bracket must appear on the same line as the
pattern, however. Also note that inside an action, we can use <code >Scanner</code>'s
members. E.g., <code >matched()</code> contains the text of the token that was last
matched.  The following <code >main</code> function can be used to activate the
generated scanner.
<p>
<pre >
#include "Scanner.h"

int main()
{
	Scanner scanner;
	scanner.lex();
}
</pre>

<p>
Note how simple this function is. <code >Scanner::lex()</code> does not
return until the entire input stream has been processed, because none of
the patterns has an associated action using a return statement.
<p>
<a name="l6"></a>
<h3 >1.2.2: An interactive scanner supporting command-line editing</h3>
        The <strong >flexc++</strong>(1) manual page contains an example of an <em >interactive</em>
scanner. Let's add command-line editing and command-line history to that
scanner. 
<p>
Command-line editing and history is provided by the Gnu readline library. The
<a href="http://bobcat.sourceforge.net/">bobcat</a> library offers a class
<code >FBB::ReadLineStream</code> encapsulating Gnu's readline library's facilities.
This class wass used by the following example to implement the required
features.
<p>
The lexical scanner is a simple one. It recognizes <strong >C++</strong> identifiers and
<code >\n</code> characters, and ignores all other characters. Here is its
specification:
    <pre>

%class-name Scanner
%interactive

%%

[[:alpha:]_][[:alnum:]_]*   return 1;
\n                          return '\n';
.
    
</pre>

    Create the lexical scanner from this specification file:
        <pre>

    flexc++ lexer
        
</pre>

<p>
Assuming that the directory containing the specification file also
contains the file <code >main.cc</code> whose implementation is shown below, then
execute the following command to create the interactive scanner program:
        <pre>

    g++ *.cc -lbobcat
        
</pre>

    This completes the construction of the interactive scanner. Here is
the file <code >main.cc</code>:
        <pre>

#include &lt;iostream&gt;
#include &lt;bobcat/readlinestream&gt;

#include "Scanner.h"

using namespace std;
using namespace FBB;

int main()
{
    ReadLineStream rls("? ");       // create the ReadLineStream, using "? "
                                    // as a prompt before each line
                                    
    Scanner scanner(rls);           // pass `rls' to the interactive scanner

                                    // process all the line's tokens
                                    // (the prompt is provided by `rls')
    while (int token = scanner.lex())
    {                                   
        if (token == '\n')          // end of line: new prompt
            continue;
                                    // process other tokens
        cout &lt;&lt; scanner.matched() &lt;&lt; '\n';
        if (scanner.matched()[0] == 'q')
            return 0;
    }
}
    
</pre>

    An interactive session with the above program might look like this
(end-of-line comment is not entered, but was added by us for documentary
purposes):
        <pre>
   
    $ a.out
    ? hello world               // enter some words
    hello 
    world                       // echoed after pressing Enter
    ? hello world               // this is shown after pressing up-arrow
    ? hello world^H^H^Hman      // do some editing and press Enter
    hello                       // the tokens as edited are returned 
    woman
    ? q                         // end the program
    $
        
</pre>

    The interactive scanner only supports one constructor, by default using
<code >std::cin</code>, to read from, and by default using <code >std::cout</code> to write to:
        <pre>

    explicit Scanner(std::istream &amp;in = std::cin,
                     std::ostream &amp;out = std::cout);
        
</pre>

    Interactive scanners only support switching output streams (through
<code >switchOstream</code> members).
<p>
<hr>
<ul>
    <li> <a href="flexc++.html">Table of Contents</a>
    <li> <a href="flexc++02.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
