<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>flexc++api</title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr/>
<h1 id="title">flexc++api</h1>
<h2 id="author">flexc++.2.04.00.tar.gz</h2>
<h2 id="date">2008-2016</h2>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr/>
<h1 id="title"></h1>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>flexc++api(3)</title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr/>
<h1 id="title">flexc++api(3)</h1>
<h2 id="author">flexc++.2.04.00.tar.gz flexc++ API</h2>
<h2 id="date">2008-2016</h2>


<p>

<h2>NAME</h2>flexc++api - Application programmer's interface of flexc++ generated classes
<p>
<h2>DESCRIPTION</h2>
<p>
<strong>Flexc++</strong>(1) was designed after <strong>flex</strong>(1) and <strong>flex++</strong>(1). Like these
latter two programs <strong>flexc++</strong> generates code performing pattern-matching on text,
possibly executing actions when certain <em>regular expressions</em> are
recognized.
<p>
Refer to <strong>flexc++</strong>(1) for a general overview. This manual page covers
the Application Programmer's Interface of classes generated by <strong>flexc++</strong>, offering
the following sections:
<p>
<ul>
    <li> <strong>1. INTERACTIVE SCANNERS</strong>: how to create an interactive scanner
<p>
<li> <strong>2. THE CLASS INTERFACE: SCANNER.H</strong>: Constructors and members
        of the scanner class generated by <strong>flexc++</strong> 
    <li> <strong>3. NAMING CONVENTION</strong>: symbols defined by <strong>flexc++</strong> in the scanner
        class. 
    <li> <strong>4. CONSTRUCTORS</strong>: constructors defined in the scanner class.
    <li> <strong>5. PUBLIC MEMBER FUNCTION</strong>: public member declared in the scanner
        class.
    <li> <strong>6. PRIVATE MEMBER FUNCTIONS</strong>: private members declared in the
        scanner class.
    <li> <strong>7. SCANNER CLASS HEADER EXAMPLE</strong>: an example of a generated
        scanner class header
<p>
<li> <strong>8. THE SCANNER BASE CLASS</strong>: the scanner class is derived from a
        base class. The base class is described in this section
    <li> <strong>9. PUBLIC ENUMS AND -TYPES</strong>: enums and types declared by the
        base class
    <li> <strong>10. PROTECTED ENUMS AND -TYPES</strong>: enumerations and types used by
        the scanner and scanner base classes
    <li> <strong>11. NO PUBLIC CONSTRUCTORS</strong>: the scanner base class does not
        offer public constructors.
    <li> <strong>12. PUBLIC MEMBER FUNCTIONS</strong>: several members defined by the
        scanner base class have public access rights.
    <li> <strong>13. PROTECTED CONSTRUCTORS</strong>: the base class can be constructed by
        a derived class. Usually this is the scanner class generated by <strong>flexc++</strong>.
    <li> <strong>14. PROTECTED MEMBER FUNCTIONS</strong>: this section covers the base
        class member functions that can only be used by scanner class or
        scanner base class members
    <li> <strong>15. PROTECTED DATA MEMBERS</strong>: this section covers the base class
        data members that can only be used by scanner class or scanner base
        class members
    <li> <strong>16. FLEX++ TO FLEXC++ MEMBERS</strong>: a short overview of frequently
        used <strong>flex</strong>(1) members that received different names in <strong>flexc++</strong>.
<p>
<li> <strong>17. THE CLASS INPUT</strong>: the scanner's job is completely decoupled
        from the actual input stream. The class <em>Input</em>, nested within the
        scanner base class handles the communication with the input
        streams. The  class <em>Input</em>, is described in this section.
    <li> <strong>18. INPUT CONSTRUCTORS</strong>: the class <em>Input</em> can easily be
        replaced by another class. The constructor-requirements are described
        in this section.
    <li> <strong>19. REQUIRED PUBLIC MEMBER FUNCTIONS</strong>: this section covers the
        required public members of a self-made <em>Input</em> class
    </ul>
<p>
<h2>1. INTERACTIVE SCANNERS</h2>
<p>
An interactive scanner is characterized by the fact that scanning is postponed
until an end-of-line character has been received, followed by reading all
information on the line, read so far. <strong>Flexc++</strong> supports the 
<em>%interactive</em> directive), generating an
interactive scanner. Here it is assumed that <em>Scanner</em> is the name of the
scanner class generated by <strong>flexc++</strong>.
<p>
<strong>Caveat:</strong> generating interactive and non-interactive scanners should not be
mixed as their class organizations fundamentally differ, and several of the
Scanner class's members are only available in the non-interactive scanner. As
the <em>Scanner.h</em> file contains the Scanner class's interface, which is
normally left untouched by <strong>flexc++</strong>, <strong>flexc++</strong> cannot adapt the Scanner class when
requested to change the interactivity of an existing Scanner class. Because of
this support for the <em>--interactive</em> option was discontinued at <strong>flexc++</strong>'s
1.01.00 release.
<p>
The interactive scanner generated by <strong>flexc++</strong> has the following characteristics:
    <ul>
    <li> The <em>Scanner</em> class is derived privately from
        <em>std::istringstream</em> and (as usual) publicly from <em>ScannerBase</em>.
    <li> The <em>istringstream</em> base class is constructed by its default
        constructor. 
    <li> The function <em>lex</em>'s default implementation is removed from
        <em>Scanner.h</em> and is implemented in the generated <em>lex.cc</em> source
        file. It performs the following tasks:
<p>
- If the token returned by the scanner is not equal to 0 it is
            returned as then next token;
<p>
- Otherwise the next line is retrieved from the input stream
            passed to the <em>Scanner</em>'s constructor (by default <em>std::cin</em>).
            If this fails, 0 is returned.
<p>
- A <em>'\n'</em> character is appended to the just read line, and the
            scanner's <em>std::istringstream</em> base class object is
            re-initialized with that line;
<p>
- The member <em>lex__</em> returns the next token.
    </ul>
    This implementation allows code calling <em>Scanner::lex()</em> to conclude, as
usual, that the input is exhausted when <em>lex</em> returns 0.
<p>
Here is an example of how such a scanner could be used:
    <ul>
        <pre>

    // scanner generated using 'flexc++ lexer' with lexer containing 
    // the %interactive directive
    int main()
    {
        Scanner scanner;        // by default: read from std::cin 
    
        while (true)
        {
            cout &lt;&lt; "? ";       // prompt at each line

            while (true)        // process all the line's tokens
            {
                int token = scanner.lex();
    
                if (token == '\n')  // end of line: new prompt
                    break;
    
                if (token == 0)     // end of input: done
                    return 0;
    
                                    // process other tokens
                cout &lt;&lt; scanner.matched() &lt;&lt; '\n';
                if (scanner.matched()[0] == 'q')
                    return 0;
            }
        }
    }
        
</pre>

    </ul>
<p>
<h2>2. THE CLASS INTERFACE: SCANNER.H</h2>
<p>
By default, <strong>flexc++</strong> generates a file <em>Scanner.h</em> containing the initial
interface of the scanner class performing the lexical scan according to the
specifications given in <strong>flexc++</strong>'s input file. The name of the file that is
generated can easily be changed using <strong>flexc++</strong>'s <em>--class-header</em>
option. In this man-page we'll stick to using the default name.
<p>
The file <em>Scanner.h</em> is generated only once, unless an explicit request
is made to rewrite it (using <strong>flexc++</strong>'s <em>--force-class-header</em> option).
<p>
The provided interface is very light-weight, primarily offering a link to
the scanner's base class (see this manpage's sections 8 through 16).
<p>
<strong>Many of the facilities offered by the scanner class are inherited from
the <em>ScannerBase</em> base class. Additional facilities offered by the
<em>Scanner</em> class. are covered below</strong>.
<p>
<h2>3. NAMING CONVENTION</h2>
<p>
All symbols that are required by the generated scanner class end in two
consecutive underscore characters (e.g., <em>executeAction__</em>). These names
should not be redefined. As they are part of the <em>Scanner</em> and
<em>ScannerBase</em> class their scope is immediately clear and confusion with
identically named identifiers elsewhere is unlikely.
<p>
Some member functions do not use the underscore convention. These are the
scanner class's constructors, or names that are similar or equal to names that
have historically been used (e.g., <em>length</em>). Also, some functions are
offered offering hooks into the implementation (like <em>preCode</em>). The latter
category of function also have names that don't end in underscores.
<p>
<h2>4. CONSTRUCTORS</h2>
<p>
<ul>
    <li> <strong>explicit Scanner(std::istream &amp;in = std::cin, 
                    std::ostream &amp;out = std::cout)</strong>
        This constructor by default reads information from the standard input
stream and writes to the standard output stream. When the
<em>Scanner</em> object goes out of scope the input and output files are closed.
<p>
With interactive scanners input stream switching or stacking is not
available; switching output streams, however, is.
<p>
<li> <strong>Scanner(std::string const &amp;infile, std::string const &amp;outfile)</strong>
        This constructor opens the input and output streams whose file names
were specified. When the <em>Scanner</em> object goes out of scope the input and
output files are closed. If <em>outfile == "-"</em> then the standard output stream
is used as the scanner's output medium; if <em>outfile == ""</em> then the
standard error stream is used as the scanner's output medium. 
<p>
<strong>This constructor is not available with interactive scanners.</strong>
    </ul>
<p>
<h2>5. PUBLIC MEMBER FUNCTIONS</h2>
<p>
<ul>
    <li> <strong>int lex()</strong>
        The <em>lex</em> function performs the lexical scanning of the input file
specified at construction time (but also see section 6.1. for information
about intermediate stream-switching facilities). It returns an <em>int</em>
representing the <em>token</em> associated with the matched regular expression. The
returned value 0 indicates end-of-file. Considering its default
implementation, it could be redefined by the user. <em>Lex</em>'s default
implementation merely calls <em>lex__</em>:
        <pre>

inline int Scanner::lex()
{
    return lex__();
}
        
</pre>

<p>
<strong>Caveat</strong>: with interactive scanners the <em>lex</em> function is defined in
the generated <em>lex.cc</em> file. Once <strong>flexc++</strong> has generated the scanner class
header file this scanner class header file isn't automatically rewritten by
<strong>flexc++</strong>. If, at some later stage, an interactive scanner must be generated, then
the inline <em>lex</em> implementation must be removed `by hand' from the scanner
class header file. Likewise, a <em>lex</em> member implementation (like the above)
must be provided `by hand' if a non-interactive scanner is required after
first having generated files implementing an interactive scanner.
    </ul>
<p>
<h2>6. PRIVATE MEMBER FUNCTIONS</h2>
<p>
<ul>
    <li> <strong>int lex__()</strong>
        This function is used internally by <em>lex</em> and should not otherwise
be used.
    <li> <strong>int executeAction__()</strong>
        This function is used internally by <em>lex</em> and should not otherwise
be used.
    <li> <strong>void preCode()</strong>
        By default this function has an empty, inline implementation in
<em>Scanner.h</em>. It can safely be replaced by a user-defined
implementation. This function is called by <em>lex__</em>, just before it starts to
match input characters against its rules: <em>preCode</em> is called by <em>lex__</em>
when <em>lex__</em> is called and also after having executed the actions of a rule
which did not execute a <em>return</em> statement. The outline of <em>lex__</em>'s
implementation looks like this:
        <pre>

int Scanner::lex__()
{
    ...
    preCode();

    while (true)
    {
        size_t ch = get__();            // fetch next char
        ...
        switch (actionType__(range))    // determine the action
        {
            ... maybe return
        }
        ... no return, continue scanning
        preCode();
    } // while
}
        
</pre>

    <li> <strong>void postCode(PostEnum__ type)</strong>
        By default this function has an empty, inline implementation in
<em>Scanner.h</em>. It can safely be replaced by a user-defined
implementation. This function is called by <em>lex__</em>, just after a rule has
been matched. Values of the <em>enum class PostEnum__</em> indicate the
characteristic of the matched rule. <em>PostEnum__</em> has four values:
<em>PostEnum__::END, PostEnum__::POP, PostEnum__::RETURN</em>, and
<em>PostEnum__::WIP</em>. Refer to section 10 for their meanings.
   <li> <strong>void print()</strong>
           When the <em>--print-tokens</em> or <em>%print-tokens</em> directive is used
            this function is called to display, on the standard output stream,
            the tokens returned and text matched by the scanner generated by
            <strong>flexc++</strong>.
<p>
Displaying is suppressed when the <em>lex.cc</em> file is (re)generated
            without using this directive. The function actually showing the
            tokens (<em>ScannerBase::print__</em>) is called from <em>print</em>, which
            is defined in-line in <em>Scanner.h</em>. Calling
            <em>ScannerBase::print__</em>, therefore, can also easily be controlled
            by an option controlled by the program using the scanner object.
     </ul>
<p>
<h2>7. SCANNER CLASS HEADER EXAMPLE</h2>
<p>
<pre>

#ifndef Scanner_H_INCLUDED_
#define Scanner_H_INCLUDED_

// $insert baseclass_h
#include "Scannerbase.h"

// $insert classHead
class Scanner: public ScannerBase
{
    public:
        explicit Scanner(std::istream &amp;in = std::cin,
                                std::ostream &amp;out = std::cout);

        Scanner(std::string const &amp;infile, std::string const &amp;outfile);
        
        // $insert lexFunctionDecl
        int lex();

    private:
        int lex__();
        int executeAction__(size_t ruleNr);

        void print();
        void preCode();     // re-implement this function for code that must 
                            // be exec'ed before the patternmatching starts

        void postCode(PostEnum__ type);    
                            // re-implement this function for code that must 
                            // be exec'ed after the rules's actions.
};

// $insert scannerConstructors
inline Scanner::Scanner(std::istream &amp;in, std::ostream &amp;out)
:
    ScannerBase(in, out)
{}

inline Scanner::Scanner(std::string const &amp;infile, std::string const &amp;outfile)
:
    ScannerBase(infile, outfile)
{}

// $insert inlineLexFunction
inline int Scanner::lex()
{
    return lex__();
}

inline void Scanner::preCode() 
{
    // optionally replace by your own code
}

inline void Scanner::postCode(PostEnum__ type) 
{
    // optionally replace by your own code
}

inline void Scanner::print() 
{
    print__();
}

#endif // Scanner_H_INCLUDED_
        
</pre>

<p>
<h2>8. THE SCANNER BASE CLASS</h2>
<p>
By default, <strong>flexc++</strong> generates a file <em>Scannerbase.h</em> containing the
interface of the base class of the scanner class also generated by <strong>flexc++</strong>. The
name of the file that is generated can easily be changed using <strong>flexc++</strong>'s
<em>--baseclass-header</em> option. In this man-page we use the default name.
<p>
The file <em>Scannerbase.h</em> is generated at each new <strong>flexc++</strong> run. It contains
no user-serviceable or extensible parts. Rewriting can be prevented by
specifying <strong>flexc++</strong>'s <em>--no-baseclass-header</em> option).
<p>
<h2>9. PUBLIC ENUMS AND -TYPES</h2>
<p>
<ul>
    <li> <strong>enum class StartCondition__</strong>
        This strongly typed enumeration defines the names of the start
conditions (i.e., mini scanners). It at least contains <em>INITIAL</em>, but when
the <em>%s</em> or <em>%x</em> directives were used it also contains the identifiers of
the mini scanners declared by these directives. Since <em>StartCondition__</em> is
a strongly typed enum its values must be preceded by its enum name. E.g.,
        <pre>

    begin(StartCondition__::INITIAL);
        
</pre>

    </ul>
<p>
<h2>10. PROTECTED ENUMS AND -TYPES</h2>
<p>
<ul>
    <li> <strong>enum class ActionType__</strong>
        This strongly typed enumeration is for internal use only.
    <li> <strong>enum Leave__</strong>
        This enumeration is for internal use only.
    <li> <strong>enum class PostEnum__</strong>
        Values of this strongly typed enumeration are passed to the scanner's
        private member <em>postCode</em>, indicating the scanner's action after
        matching a rule. The values of this enumeration are:
<p>
<em>PostEnum__::END</em>: the function <em>lex__</em>  immediately returns 0
            once <em>postCode</em> returns, indicating the end of the input was
            reached;
<p>
<em>PostEnum__::POP</em>: the end of an input stream was reached, and
            processing continues with the previously pushed input stream. In
            this case the function <em>lex__</em> doesn't return, it simply
            coontinues processing the previously pushed stream;
<p>
<em>PostEnum__::RETURN</em>: the function <em>lex__</em> immediately returns 
            once <em>postCode</em> returns, returning the next token;
<p>
<em>PostEnum__::WIP</em>: the function <em>lex__</em> has matched a
            non-returning rule, and continues its rule-matching process.
    </ul>
<p>
<h2>11. NO PUBLIC CONSTRUCTORS</h2>
<p>
There are no public constructors. <em>ScannerBase</em> is a base class for the
<em>Scanner</em> class generated by <strong>flexc++</strong>. <em>ScannerBase</em> only offers 
protected constructors.
<p>
<h2>12. PUBLIC MEMBER FUNCTIONS</h2>
<p>
<ul>
    <li> <strong>bool debug() const</strong>
       returns <em>true</em> if <em>--debug</em> or <em>%debug</em> was specified, otherwise
        <em>false</em>.
<p>
<li> <strong>bool interactiveLine()</strong>
       this member is only available with interactive scanners. All remaining
        contents of the current interactive line buffer is discarded, and the
        interactive line buffer is filled with the contents of the next input
        line. This member can be used when a condition is encountered which
        invalidates the remaining contents of a line. Following a call to
        <em>interactiveLine</em> the next token that is returned by the lexical
        scanner will be the first token on the next line. This member returns
        <em>true</em> if the next line is available and <em>false</em> otherwise.
<p>
<li> <strong>std::string const  &amp;filename()  const</strong>
       returns the name of the file currently processed by the scanner object.
    <li> <strong>size_t              length()    const</strong>
       returns the length of the text that was matched by <em>lex</em>. With
        <strong>flex++</strong> this function was called <em>leng</em>.
    <li> <strong>size_t              lineNr()    const</strong>
       returns the line number of the currently scanned line. This function is
        always available (note: <strong>flex++</strong> only offered a similar function
        (called <em>lineno</em>) after using the <em>%lineno</em> option).
    <li> <strong>std::string const  &amp;matched()   const</strong>
       returns the text matched by <em>lex</em> (note: <strong>flex++</strong> offers a similar
        member called <em>YYText</em>).
    <li> <strong>void setDebug(bool onOff)</strong>
       Switches on/off  debugging output by providing the argument <em>true</em>
        or <em>false</em>. Switching on debugging output only has visible effects
        if the <em>debug</em> option was specified.
<p>
    <li> <strong>void switchIstream(std::string const &amp;infilename)</strong>
       The currently processed input stream is closed, and processing
        continues at the stream whose name is specified as the function's
        argument. This is <em>not</em> a stack-operation: after processing
        <em>infilename</em> processing does not return to the original stream.
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
<li> <strong>void switchOstream(std::ostream &amp;out)</strong>
       The currently processed output stream is closed, and
        new output is written to <em>out</em>. 
<p>
<li> <strong>void switchOstream(std::string const &amp;outfilename)</strong>
<p>
The current output stream is closed, and output is written to
        <em>outfilename</em>. If this file already exists, it is rewritten.
<p>
<li> <strong>void switchStreams(std::istream &amp;in,
                                      std::ostream &amp;out = std::cout)</strong>
       The currently processed input and output streams are closed, and
        processing continues at <em>in</em>, writing output to <em>out</em>. This is
        <em>not</em> a stack-operation: after processing <em>in</em> processing
        does not return to the original stream.
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
<li> <strong>void switchStreams(std::string const &amp;infilename,
                                      std::string const &amp;outfilename)</strong>
       The currently processed input and output streams are closed, and
        processing continues at the stream whose name is specified as the
        function's first argument, writing output to the file whose name is
        specified as the function's second argument. This latter file is
        rewritten. This is <em>not</em> a stack-operation: after processing
        <em>infilename</em> processing does not return to the original stream.
        If <em>outfilename == "-"</em> then the standard output stream
        is used as the scanner's output medium; if <em>outfilename == ""</em> then
        the standard error stream is used as the scanner's output medium.
<p>
If <em>outfilename == "-"</em> then the standard output stream
        is used as the scanner's output medium; if <em>outfilename == ""</em> then
        the standard error stream is used as the scanner's output medium.
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
</ul>
<p>
<h2>13. PROTECTED CONSTRUCTORS</h2>
<p>
<ul>
    <li> <strong>ScannerBase(std::string const &amp;infilename, 
                                std::string const &amp;outfilename)</strong>
       The scanner object opens and reads <em>infilename</em> and opens (rewrites)
        and writes <em>outfilename</em>. It is called from the corresponding
        <em>Scanner</em> constructor.
<p>
<strong>This member is not available for interactive scanners.</strong>
<p>
<li> <strong>ScannerBase(std::istream &amp;in, std::ostream &amp;out)</strong>
       The <em>in</em> and <em>out</em> parameters are, respectively, the derived class
        constructor's input stream and output streams.
    </ul>
<p>
<h2>14. PROTECTED MEMBER FUNCTIONS</h2>
<p>
All member functions ending in two underscore characters are for internal
        use only and should not be called by user-defined members of the
        <em>Scanner</em> class. 
<p>
The following members, however, can safely be called by members of the
        generated <em>Scanner</em> class:
<p>
<ul>
    <li> <strong>void accept(size_t nChars = 0)</strong>
       <em>accept(n)</em> returns all but the first `nChars' characters of the
        current token back to the input stream, where they will be rescanned
        when the scanner looks for the next match.  So, it matches `nChars' of
        the characters in the input buffer, rescanning the rest. This function
        effectively sets <em>length</em>'s return value to <em>nChars</em> (note: with
        <strong>flex++</strong> this function was called <em>less</em>);
<p>
<li> <strong>void begin(StartCondition__ startCondition)</strong>
       activate the regular expression rules associated with
        <em>StartCondition__ startCondition</em>. As this enumeration is a strongly
        typed enum the <em>StartCondition__</em> scope must be specified as
        well. E.g., 
            <pre>

        begin(StartCondition__::INITIAL);
            
</pre>

<p>
<li> <strong>void echo() const</strong> 
       The currently matched text (i.e., the text returned by the member
        <em>matched</em>) is inserted into the scanner object's output stream;
<p>
<li> <strong>void leave(int retValue)</strong>
       actions defined in the lexical scanner specification file may or may
        not return. This frequently results in complicated or overlong
        compound statements, blurring the readability of the specification
        file. By encapsulating the actions in a member function readability is
        enhanced. However, frequently a compound statement is still required,
        as in:
            <pre>

    regex-to-match  {
                        if (int ret = memberFunction())
                            return ret;
                    }
            
</pre>

        The member <em>leave</em> removes the need for constructions like the
        above. The member <em>leave</em> can be called from within member
        functions encapsulating actions performed when a regular expression
        has been matched. It ends <em>lex</em>, returning <em>retValue</em> to its
        caller. The above rule can now be written like this:
            <pre>

    regex-to-match  memberFunction();
            
</pre>

        and <em>memberFunction</em> could be implemented as follows:
            <pre>

    void memberFunction()
    {
        if (someCondition())
        {                           // any action, e.g., 
                                    // switch mini-scanner
            begin(StartCondition__::INITIAL);

            leave(Parser::TOKENVALUE);    // lex returns TOKENVALUE
            // this point is never reached
        }
    
        pushStream(d_matched);      // switch to the next stream
                                    // lex continues
    }
            
</pre>

       The member <em>leave</em> should only (indirectly) be called 
        (usually nested) from actions defined in the scanner's specification
        <strong>s</strong>; calling <em>leave</em> outside of this context results in
        undefined behavior.
<p>
<li> <strong>void more()</strong>
       the matched text is kept and will be prefixed to the text that is
        matched at the next lexical scan;
<p>
<li> <strong>std::ostream &amp;out()</strong>
       returns a reference to the scanner's output stream;
<p>
<li> <strong>bool popStream()</strong>
       closes the currently processed input stream and continues to process
        the most recently stacked input stream (removing it from the stack of
        streams). If this switch was successfully performed <em>true</em> is
        returned, otherwise (e.g., when the stream stack is empty) <em>false</em>
        is returned;
<p>
<li> <strong>void push(size_t ch)</strong>
       character <em>ch</em> is pushed back onto the input stream. I.e., it will be
        the character that is retrieved at the next attempt to obtain a
        character from the input stream;
<p>
<li> <strong>void push(std::string const &amp;txt)</strong>
       the characters in the string <em>txt</em> are pushed back onto the input
        stream. I.e., they will be the characters that are retrieved at the
        next attempt to obtain characters from the input stream. The
        characters in <em>txt</em> are retrieved from the first character to the
        last. So if <em>txt == "hello"</em> then the <em>'h'</em> will be the character
        that's retrieved next, followed by <em>'e'</em>, etc, until <em>'o'</em>;
<p>
<li> <strong>void pushStream(std::istream &amp;curStream)</strong>
        this function pushes <em>curStream</em> on the stream stack;
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
<li> <strong>void pushStream(std::string const &amp;curName)</strong>
       same, but the stream <em>curName</em> is opened first, and the resulting
        <em>istream</em> is pushed on the stream stack;
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
<li> <strong>void redo(size_t nChars = 0)</strong>
       this member acts like <em>accept</em> but its argument counts backward from
        the end of the matched text. All but these <em>nChars</em> characters are
        kept and the last <em>nChar</em> characters are rescanned. This function
        effectively reduces <em>length</em>'s return value by <em>nChars</em>;
<p>
<li> <strong>void setFilename(std::string const &amp;name)</strong>
       this function sets the name of the stream returned by <em>filename</em> to
        <em>name</em>;
<p>
<li> <strong>void setMatched(std::string const &amp;text)</strong>
       this function stores <em>text</em> in the matched text buffer. Following a
        call to this function <em>matched</em> returns <em>text</em>.
<p>
<li> <strong>StartCondition__  startCondition() const</strong>
       returns the currently active start condition (mini scanner);
<p>
<li> <strong>std::vector&lt;StreamStruct&gt; const &amp;streamStack() const</strong>
       returns the vector of currently stacked input streams. The vector's
        size equals 0 unless <em>pushStream</em> has been used. So <strong>flexc++</strong>'s input
        file is not counted here. The <em>StreamStruct</em> is a <em>struct</em> only
        having one accessible member: <em>std::string const &amp;pushedName</em>, which
        holds the name of the pushed stream. The vector is used internally 
        as a stack: the stream that was first pushed is found at index
        position 0, the most recently pushed stream is found at
        <em>streamStack().back()</em>. 
<p>
<strong>This member is not available with interactive scanners.</strong>
<p>
</ul>
<p>
<h2>15. PROTECTED DATA MEMBERS</h2>
<p>
All protected data members are for internal use only, allowing <em>lex__</em>
to access them. All of them end in two underscore characters.
<p>
<h2>16. FLEX++ TO FLEXC++ MEMBERS</h2>
<p>

<table>

    <td colspan=3><hr/></td>
   
    
<tr>
<td> Flex++ (old)</td>  <td> </td>  <td> Flexc++ (new)</td>
 
</tr>

    <td colspan=3><hr/></td>
   
    
<tr>
<td> <em>lineno()</em></td>    <td> </td>  <td> <em>lineNr()</em></td>
 
</tr>

    
<tr>
<td> <em>YYText()</em></td>    <td> </td>  <td> <em>matched()</em></td>
 
</tr>

    
<tr>
<td> <em>less()</em></td>      <td> </td>  <td> <em>accept()</em></td>
 
</tr>

    <td colspan=3><hr/></td>
   

</table>
<p>
<h2>17. THE CLASS INPUT</h2>
<p>
<strong>Flexc++</strong> generates a file <em>Scannerbase.h</em> defining the scanner class's base
class, by default named <em>ScannerBase</em> (which is the name used in this
man-page). The base class <em>ScannerBase</em> contains a nested class <em>Input</em>
whose interface looks like this:
        <pre>

class Input
{
    public:
        Input();
        Input(std::istream *iStream, size_t lineNr = 1);
        size_t get();
        size_t lineNr() const;          
        size_t nPending() const;          
        void setPending(size_t nPending);          
        void reRead(size_t ch);
        void reRead(std::string const &amp;str, size_t fmIdx);
        void close();
};
        
</pre>
        
    The members of this class are all required and offer a level in between
the operations of <em>ScannerBase</em> and <strong>flexc++</strong>'s actual input file that's being
processed. 
<p>
By default, <strong>flexc++</strong> provides an implementation for all of <em>Input</em>'s
required members. Therefore, in most situations this section of this man-page
can safely be ignored.
<p>
However, users may define and extend their own <em>Input</em> class and provide
<strong>flexc++</strong>'s base class with that <em>Input</em> class. To do so <strong>flexc++</strong>'s rules file must
contain the following two directives:
        <pre>

       %input-implementation = "sourcefile"
       %input-interface = "interface"
        
</pre>

    Here, <em>interface</em> is the name of a file containing the class <em>Input</em>'s
interface. This interface is then inserted into <em>ScannerBase</em>'s interface
instead of the default class <em>Input</em>'s interface. This interface must <em>at
least</em> offer the aforementioned members and constructors (their functions are
described below). The class may contain additional members if required by the
user-defined implementation. The implementation itself is expected in
<em>sourcefile</em>. The contents of this file are inserted in the generated
<em>lex.cc</em> file instead of <em>Input</em>'s  default implementation. The file
<em>sourcefile</em> should probably not have a <em>.cc</em> extension to prevent its
compilation by a program maintenance utility.
<p>
When the lexical scanner generated by <strong>flexc++</strong> switches streams using the
<em>//include</em> directive (see also section <strong>2. FILE SWITCHING</strong>) in the
<strong>flexc++input</strong>(7) man page), then the input stream that's currently
processed is pushed on an <em>Input</em> stack maintained by <em>ScannerBase</em>, and
processing continues at the file named at the <em>//include</em> directive. Once
the latter file has been processed, the previously pushed stream is popped off
the stack, and processing of the popped stream continues. This implies that
<em>Input</em> objects must be `stack-able'. The required interface is designed to
satisfy this requirement.
<p>
<h2>18. INPUT CONSTRUCTORS</h2>
<p>
<ul>
    <li> <strong>Input()</strong>
        The default constructor is used by <strong>ScannerBase</strong> to prepare the
stack for <em>Input</em> objects. It must make sure that a default (empty)
<em>Input</em> object is in a valid state and can be destroyed. It serves no
further purpose. <em>Input</em> objects, however, must support the default (or
overloaded) assignment operator.
    <li> <strong>Input(std::istream *iStream, size_t lineNr = 1)</strong>
        This constructor receives a pointer to a dynamically allocated
<em>istream</em> object. The <em>Input</em> constructor should preserve this pointer
when the <em>Input</em> object is pushed on and popped off the stack. A
<em>shared_ptr</em> probably comes in handy here. The <em>Input</em> object becomes the
owner of the <em>istream</em> object, albeit that its destructor is <em>not</em>
supposed to destroy the <em>istream</em> object. Destruction remains the
responsibility of the <em>ScannerBase</em> object, which calls the <em>Input::close</em>
member (see below) when it's time to destroy (close) the stream.
<p>
The new input stream's line counter is set to <em>lineNr</em>, by default
1. 
    </ul>
<p>
<h2>19. REQUIRED PUBLIC MEMBER FUNCTIONS</h2>
<p>
<ul>
    <li> <strong>size_t get()</strong>
        returns the next character to be processed by the lexical
scanner. Usually it will be the next character from the <em>istream</em> passed to
the <em>Input</em> class at construction time. It is never called by the
<em>ScannerBase</em> object for <em>Input</em> objects defined using <em>Input</em>'s default
constructor. It should return 0x100 once <em>istream</em>'s end-of-file has been
reached. 
    <li> <strong>size_t lineNr() const</strong> 
        should return the (1-based) number of the <em>istream</em> object passed to
the <em>Input</em> object. At construction time the <em>istream</em> has just been
opened and so at that point <em>lineNr</em> should return 1.
    <li> <strong>size_t nPending() const</strong> 
        should return the number of pending characters (i.e., the number of
characters which were passed back to the <em>Input</em> object using its <em>reRead</em>
members which were not yet retrieved again by its <em>get</em> member).
    <li> <strong>void setPending(size_t nPending)</strong>
        should remove <em>nPending</em> characters from the head of the <em>Input</em>
object's pending input queue. The lexical scanner always passes the value
received from <em>nPending</em> to <em>setPending</em>, without calling <em>get</em> in
between.
     <li> <strong>void reRead(size_t ch)</strong>
       if provided with a value smaller than 0x100 <em>ch</em> should be pushed
back onto the <em>istream</em>, where it becomes the character next to be
returned. Physically the character doesn't have to be pushed back. The default
implementation uses a <em>deque</em> onto which the character is pushed-front. Only
when this <em>deque</em> is exhausted characters are retrieved from the <em>Input</em>
object's <em>istream</em>.
    <li> <strong>void reRead(std::string const &amp;str, size_t fmIdx)</strong>
        the characters in <em>str</em> from <em>fmIdx</em> until the string's final
character are pushed back onto the <em>istream</em> object so that the string's
first character is retrieved first and the string's last character is
retrieved last. 
    <li> <strong>void close()</strong> 
        the <em>istream</em> object initially passed to the <em>Input</em> object is
deleted by <em>close</em>, thereby not only freeing the stream's memory, but also
closing the stream if the stream in fact was an <em>ifstream</em>. Note that the
<em>Input</em>'s destructor should <em>not</em> destroy the <em>Input</em>'s <em>istream</em>
object.
    </ul>
<p>
<h2>FILES</h2>
<p>
<strong>Flexc++</strong>'s default skeleton files are in <em>/usr/share/flexc++</em>.<br/>
    By default, <strong>flexc++</strong> generates the following files:
        <ul>
        <li> <em>Scanner.h</em>: the header file containing the scanner class's
            interface. 
        <li> <em>Scannerbase.h</em>: the header file containing the interface of the 
            scanner class's base class.
        <li> <em>Scanner.hh</em>: the internal header file that is meant to be included
            by the scanner class's source files (e.g., it is included by
            <em>lex.cc</em>, see the next item's file), and that should contain all
            declarations required for compiling the scanner class's sources.
        <li> <em>lex.cc</em>: the source file implementing the scanner class member
            function <em>lex</em> (and support functions), performing the lexical
            scan.
    </ul>
<p>
<h2>SEE ALSO</h2>
<p>
<strong>flexc++</strong>(1), <strong>flexc++input</strong>(7)
<p>
<h2>BUGS</h2>
<p>
<ul>
    <li> Generating interactive and non-interactive scanners (see section
        1. INTERACTIVE SCANNERS) cannot be mixed.
    </ul>
<p>

<h2>COPYRIGHT</h2>
    This is free software, distributed under the terms of the 
    GNU General Public License (GPL).
<p>
<h2>AUTHOR</h2>
    Frank B. Brokken (<strong>f.b.brokken@rug.nl</strong>),<br/>
    Jean-Paul van Oosten (<strong>j.p.van.oosten@rug.nl</strong>),<br/>
    Richard Berendsen (<strong>richardberendsen@xs4all.nl</strong>) (until 2010).<br/>
<p>
