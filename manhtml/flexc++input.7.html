<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>flexc++input(7)</title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr/>
<h1 id="title">flexc++input(7)</h1>
<h2 id="author">flexc++ input file organization<br/>(flexc++.2.07.00.tar.gz)</h2>
<h2 id="date">2008-2018</h2>


<p>

<h2 >NAME</h2>flexc++input - Organization of flexc++'s input <strong >s</strong>
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Flexc++</strong>(1) was designed after <strong >flex</strong>(1) and <strong >flex++</strong>(1). Like these
two programs <strong >flexc++</strong> generates code performing pattern-matching on text,
possibly executing actions when certain <em >regular expressions</em> are
recognized.
<p>
Refer to <strong >flexc++</strong>(1) for a general overview. This manual page describes
how <strong >flexc++</strong>'s input <strong >s</strong> should be organized. It contains the following
sections:
<p>
<ul>
    <li> <strong >1. SPECIFICATION FILE(S)</strong>: the format and contents of <strong >flexc++</strong> input
        files, specifying the Scanner's characteristics
    <li> <strong >2. FILE SWITCHING</strong>: how to switch to another input specification
        file
    <li> <strong >3. DIRECTIVES</strong>: directives that can be used in input
        specification files
    <li> <strong >4. MINI SCANNERS</strong>: how to declare mini-scanners
    <li> <strong >5. DEFINITIONS</strong>: how to define symbolic names for regular
        expressions
    <li> <strong >6. %% SEPARATOR</strong>: the separator between the input specification
        sections 
    <li> <strong >7. REGULAR EXPRESSIONS</strong>: regular expressions supported by <strong >flexc++</strong>
    <li> <strong >8. SPECIFICATION EXAMPLE</strong>: an example of a specification file
    </ul>
<p>
<h2 >UNDERSCORES</h2>
Starting with version 2.07.00 <strong >flexc++</strong> reserved identifiers no longer end in two
underscore characters, but in one. This modification was necessary because
according to the <strong >C++</strong> standard identifiers having two or more consecutive
underscore characters are reserved by the language. In practice this could
require some minor modifications of existing source files  using <strong >flexc++</strong>'s
facilities, most likely limited to changing <em >StartCondition__</em> into
<em >StartCondition_</em> and changing <em >PostEnum__</em> into <em >PostEnum_</em>. 
<p>
The complete list of affected names is:
    <dl>
    <dt ><strong>Enums:</strong></dt> <blockquote >
ActionType_, Leave_, StartConditon_, PostEnum_;
</blockquote>
    <dt ><strong>Member functions:</strong></dt> <blockquote >
actionType_, continue_, echoCh_, echoFirst_,
executeAction_, getRange_, get_, istreamName_, lex_, lop1_, 
lop2_, lop3_, lop4_, lopf_, matched_, noReturn_, print_, 
pushFront_, reset_, return_;
</blockquote>
    <dt ><strong>Protected data members:</strong></dt> <blockquote >
d_in_ d_token_ s_finIdx_, s_interactive_, 
s_maxSizeofStreamStack_, s_nRules_, s_rangeOfEOF_, 
s_ranges_, s_rf_.
</blockquote>
    </dl>
<p>
<h2 >1. SPECIFICATION FILE(S)</h2>
<p>
<strong >Flexc++</strong> expects an input file containing directives and the regular
expressions that should be recognized by objects of the scanner class
generated by <strong >flexc++</strong>. In this man page the elements and organization of <strong >flexc++</strong>'s
input file is described. 
<p>
<strong >Flexc++</strong>'s input file consists of two sections, separated from each other by
a line merely containing two consecutive percent characters:
    <pre>

%%
    
</pre>

    The section before this separator contains directives; the section
following this separator contains regular expressions and possibly actions to
perform when these regular expressions are matched by the object of the
scanner class generated by <strong >flexc++</strong>. If a second line is encountered immediately
beginning with  two consecutive percent characters then this ends <strong >flexc++</strong>'s
input file processing. See also section 6 (%% SEPARATOR) below.
<p>
White space is usually ignored, as is comment, which may be of the
traditional <strong >C</strong> form (i.e., <em >/*</em>, followed by (possibly multi-line)
comment text, followed by <em >*/</em>, and it may be <strong >C++</strong> end-of-line comment:
two consecutive slashes (<em >//</em>) start the comment, which continues up to
the next newline character.
<p>
<h2 >2. FILE SWITCHING</h2>
<p>
<strong >Flexc++</strong>'s input file may be split into multiple files. This allows for the
definition of logically separate elements of the specifications in different
files. Include directives must be specified on a line of their own. To
switch to another specification file the following stanza is used:
        <pre>

//include file-location
        
</pre>

    The <em >//include</em> directive starts in the line's first column. File
locations can be absolute or relative to the location of the file containing
the <em >//include</em> directive. White space characters following <em >//include</em>
and before the end of the line are ignored. The file specification may be
surrounded by double quotes, but these double quotes are not required and are
ignored (removed) if present. All remaining characters are expected to define
the name of the file where <strong >flexc++</strong>'s rules specifications continue. Once end of
file of a sub-file has been reached, processing continues at the line beyond
the <em >//include</em> directive of the previously scanned file. The end-of-file of
the file that was initially specified when <strong >flexc++</strong> was called indicates the end
of <strong >flexc++</strong>'s rules specification.
<p>
<h2 >3. DIRECTIVES</h2>
<p>
The first section of <strong >flexc++</strong>'s input file consists of directives. In
addition it may associate regular expressions with symbolic names, allowing
you to use these identifiers in the rules section. Each directive is defined
on a line of its own. When available, directives are overridden by <strong >flexc++</strong>
command line options.
<p>
    Some directives require arguments, which are usually provided following
separating (but optional) <em >=</em> characters. Arguments of directives are text,
surrounded by double quotes (strings), or embedded in raw string literals
(rawstrings).  Double quotes or backslashes inside strings must themselves be
preceded by backslashes; these backslashes are not required when rawstrings
are used. 
<p>
The <em >%s</em> and <em >%x</em> directives are immediately followed by name lists,
consisting of identifiers separated by blanks.  Here is an example of the
definition of a directive:
        <pre>

    %class-name = "MyScanner"
        
</pre>

<p>
Directives accepting a `filename' do not accept path names, i.e., they
cannot contain directory separators (<em >/</em>); options accepting a 'pathname'
may contain directory separators. A 'pathname' using blank characters should
be surrounded by double quotes.
<p>
Some directives may generate errors. This happens when a directive conflicts
with the contents of an existing file which <strong >flexc++</strong> cannot modify (e.g., a
scanner class header file exists, but doesn't define a name space, but a
<em >%namespace</em> directive was provided). To solve the error the offending
directive could be omitted, the existing file could be removed, or the
existing file could be hand-edited according to the directive's specification.
Note that <strong >flexc++</strong> currently does not handle the opposite error condition: if a
previously used directive is omitted, then <strong >flexc++</strong> does not detect the
inconsistency. In those cases you may encounter compilation errors.
<p>
<ul>
    <li> <strong >%baseclass-header</strong> <em >= "filename"</em> <br/>
           Defines the name of the file to contain the scanner class's base
            class interface. Corresponding command-line option:
            <em >--baseclass-header</em>.
<p>
It is an error if this directive is used and an already
            existing scanner-class header file does not include
            <em >`filename'</em>. 
<p>
<li> <strong >%case-insensitive</strong><br/>
           Generates a scanner which <em >case insensitively</em> matches regular
            expressions. All regular expressions specified in <strong >flexc++</strong>'s input
            file are interpreted case insensitively and the resulting scanner
            object will case insensitively interpret its input.
<p>
Corresponding command-line option: <em >--cases-insensitive</em>.
<p>
When this directive is specified the resulting scanner does not
            distinguish between the following rules:
           <pre>

        First       // initial F is transformed to f
        first
        FIRST       // all capitals are transformed to lower case chars
                
</pre>

           With a case-insensitive scanner only the first rule can be matched,
            and <strong >flexc++</strong> will issue warnings for the second and third rule about
            rules that cannot be matched.
<p>
Input processed by a case-insensitive scanner is also handled case
            insensitively. The above mentioned <em >First</em> rule is matched for
            all of the following input words: <em >first First FIRST firST</em>. 
<p>
Although the matching process proceeds case insensitively, the
            matched text (as returned by the scanner's <em >matched()</em> member)
            always contains the original, unmodified text. So, with the above
            input <em >matched()</em> returns, respectively <em >first, First, FIRST</em>
            and <em >firST</em>, while matching the rule <em >First</em>.
<p>
<li> <strong >%class-header</strong> <em >= "filename"</em> <br/>
           Defines the name of the file to contain the scanner class's
            interface. Corresponding command-line option: <em >--class-header</em>.
<p>
<li> <strong >%class-name</strong> <em > = "className"</em> <br/>
           Declares the name of the scanner class generated by <strong >flexc++</strong>. This
            directive corresponds to the <em >%name</em> directive used by
            <strong >flex++</strong>(1). Contrary to <strong >flex++</strong>'s <em >%name</em> declaration,
            <em >class-name</em> may appear anywhere in the first section of the
            grammar specification file. It may be defined only once. If no
            <em >class-name</em> is specified the default class name (<em >Scanner</em>)
            is used. Corresponding command-line option:
            <em >--class-name</em>.
<p>
It is an error if this directive is used and an already
            existing scanner-class header file does not define <em >class
            `className'</em>.
<p>
<li> <strong >%debug</strong> <br/> 
           Provide <em >lex</em> and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the <em >setDebug(bool
            on-off)</em> member. Note that no <em >#ifdef DEBUG</em> macros are used in
            the generated code. 
<p>
<li> <strong >%filenames</strong> <em >= "basename"</em> <br/>
           Defines the basename of the <em >Scanner.h, Scanner.ih,</em> and
            <em >Scannerbase.h</em> files. E.g., when using the directive
                <pre>

    %filenames = "scanner"
                
</pre>

           the names of the generated files are, respectively, <em >scanner.h,
            scanner.ih,</em> and <em >scannerbase.h</em>.  Corresponding command-line
            option: <em >--filenames</em>. The name of the source file (by default
            <em >lex.cc</em>) is controlled by the <em >%lex-source</em> directive.
<p>
<li> <strong >%implementation-header</strong> <em >= "filename"</em> <br/>
           Defines the name of the file to contain the implementation header.
            Corresponding command-line option: <em >--implementation-header</em>.
<p>
It is an error if this directive is used and an already
            <em >'filename'</em> file does not include the scanner class header
            file.
<p>
<li> <strong >%input-implementation</strong> <em >= "sourcefile"</em> <br/>
           Defines the pathname of the file containing the implementation of a
            user-defined <em >Input</em> class. 
<p>
<li> <strong >%input-interface</strong> <em >= "interface"</em> <br/>
           Defines the pathname of the file containing the interface of a
            user-defined <em >Input</em> class. See section <strong >17. THE CLASS INPUT</strong>
            in the <strong >flexc++api</strong>(3) manual page for additional information
            about user-defined <em >Input</em> classes.
<p>
<li> <strong >%interactive</strong><br/>
           Generate an interactive scanner. An interactive scanner reads lines
            from the input stream, and then returns the tokens encountered on
            that line. The interactive scanner implemented by <strong >flexc++</strong> only
            predefines the <em >Scanner(std::istream &amp;in, std::ostream &amp;out)</em>
            constructor, by default assuming that input is read from
            <em >std::cin</em>. See also section <em >1. INTERACTIVE SCANNER</em> section
            in the <strong >flexc++api</strong>(3) manual page.
<p>
<li> <strong >%lex-function-name</strong> <em >= "funname"</em> <br/>
           Defines the name of the scanner class's member to perform the
            lexical scanning. If this directive is omitted the default name
            (<em >lex</em>) is used. Corresponding command-line option:
            <em >--lex-function-name</em>.
<p>
<li> <strong >%lex-source</strong> <em >= "filename"</em> <br/>
           Defines the name of the file to contain the scanner member
            <em >lex</em>. Corresponding command-line option: <em >--lex-source</em>.
<p>
<li> <strong >%no-lines</strong> <br/> 
           Do not put <em >#line</em> preprocessor directives in the file containing
            the scanner's <em >lex</em> function. If omitted <em >#line</em> directives
            are added to this file, unless overridden by the command line
            options <em >--lines</em> and <em >--no-lines</em>.
<p>
<li> <strong >%namespace</strong> <em >= "identifer"</em> <br/>
           Define the scanner class in the namespace <em >identifier</em>. By
            default no namespace is used. If this directives is used the
            implementation header is provided with a commented out <em >using
            namespace</em> declaration for the requested namespace.  In addition,
            the scanner and scanner base class header files also use the
            specified namespace to define their include guard directives.
<p>
It is an error if this directive is used and an already
            scanner-class header file does not define <em >namespace
            identifier</em>.
<p>
<li> <strong >%print-tokens</strong> <br/> 
           this directive results in the tokens as well as the matched text to
            be displayed on the standard output stream, just before returning
            the token to <em >lex</em>'s caller. Displaying is suppressed again when
            the <em >lex.cc</em> file is generated without using this directive. The
            function showing the tokens (<em >ScannerBase::print_</em>) is called
            from <em >Scanner::print()</em>, which is defined in-line in
            <em >Scanner.h</em>. Calling <em >ScannerBase::print_</em>, therefore, can
            also easily be controlled by an option controlled by the program
            using the scanner object.
           this directive does <em >not</em> show the tokens returned and text
            matched by <strong >flexc++</strong> itself when reading its input <strong >s</strong>. If that is
            what you want, use the <em >--own-tokens</em> option.
<p>
<li> <strong >%s</strong> <em >namelist</em> <br/>
           The <em >%s</em> directive is followed by a list of one or more
            identifiers, separated by blanks. Each identifier is the name of
            an <em >inclusive start condition</em>.
<p>
<li> <strong >%skeleton-directory</strong> <em >= "pathname"</em> <br/>
           Use <em >pathname</em> rather than the default (e.g.,
            <em >/usr/share/flexc++</em>) path when looking for <strong >flexc++</strong>'s skeleton
            files. Corresponding command-line option:
            <em >--skeleton-directory</em>.
<p>
<li> <strong >startcondition-name</strong> <em > = "startconditionName"</em> <br/>
           By default, <strong >flexc++</strong> defines the enum <em >StartCondition_</em> defining
            the names of start-conditions. The <em >%startcondition-name</em>
            directive can be used to configure another name for the enum
            containing the names of the start-conditions.  It may be defined
            only once. 
<p>
The name of the startcondition-enum may be modified, and the
            directive can also be omitted again after it has been specified
            before. When changing the name of the startcondition-enum or when
            reverting to the default name newly generated <em >lex.cc</em> and
            <em >ScannerBase.h</em> files will use the currently defined
            startcondition-enum name. Be advised, though, that the
            startcondition-enum name may also be used in user-defined members
            of the scanner-class, or in the scanner's header and internal
            header files. If so, the user is responsible for updating those
            files to the currently defined name of the startcondition-enum.
<p>
<li> <strong >%target-directory</strong> <em >= "pathname"</em> <br/>
           <em >Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong >flexc++</strong> is
            called. This directive is overruled by the <em >--target-directory</em>
            command-line option.
<p>
<li> <strong >%x</strong> <em >namelist</em> <br/>
           The <em >%x</em> directive is followed by a list of one or more
            identifiers, separated by blanks. Each identifier is the name of
            an <em >exclusive start condition</em>.
    </ul>
<p>
<h2 >4. MINI SCANNERS</h2>
<p>
Mini scanners come in two flavors: inclusive mini scanners and exclusive
mini scanners. The rules that apply to an inclusive mini scanner are the mini
scanner's own rules as well as the rules which apply to no mini scanners in
particular (i.e., the rules that apply to the default (or <em >INITIAL</em>) mini
scanner). Exclusive mini scanners only use the rules that were defined for
them. 
<p>
To define an inclusive mini scanner use <em >%s</em>, followed by one
or more identifiers specifying the name(s) of the mini-scanner(s). To define
an exclusive mini scanner use <em >%x</em>, followed by or more identifiers
specifying the name(s) of the mini-scanner(s). The following example defines
the names of two mini scanners: <em >string</em> and <em >comment</em>: 
        <pre>

    %x string comment 
        
</pre>

    Following this, rules defined in the context of the <em >string</em> mini
scanner (see below) will only be used when that mini scanner is active.
<p>
A <strong >flexc++</strong> input file may contain multiple <em >%s</em> and <em >%x</em>
specifications.
<p>
<h2 >5. DEFINITIONS</h2>
<p>
Definitions are of the form
        <pre>

identifier  regular-expression
        
</pre>

    Each definition must be entered on a line of its own. Definitions
associate identifiers with regular expressions, allowing the use of
<em >${identifier}</em> as synonym for its regular expression in the rules section
of <strong >flexc++</strong>'s input file. One defined, the identifiers representing regular
expressions can also be used in subsequent definitions.
<p>
Example:
        <pre>

FIRST                   [A-Za-z_]
NAME                    {FIRST}[-A-Za-z0-9_]*
        
</pre>

<p>
<h2 >6. %% SEPARATOR</h2>
<p>
Following directives and definitions a line merely containing two consecutive
<em >%</em> characters is expected. Following this line the rules are defined. Rules
consist of regular expressions which should be recognized, possibly followed
by actions to be executed once a rule's regular expression has been matched.
<p>
If the rule section contains a line starting with two consecutive <em >%</em>
characters, then any remaining input is ignored. Note that this second <em >%%</em>
separator does not have to be specified. It is purely optional. To specify a
regular expression starting with <em >%%</em> surround the <em >%%</em> with double quotes
(<em >"%%"</em>) or prefix the <em >%%</em> with a blank space: the <em >%%</em>-characters are
only considered a separator if they are encountered at the very beginning of a
line. 
<p>
<h2 >7. REGULAR EXPRESSIONS</h2>
<p>
The regular expressions defined in <strong >flexc++</strong>'s rules files are matched against 
the information passed to the scanner's <em >lex</em> function. 
<p>
Regular expressions begin as the first non-blank character on a line. Comment
is interpreted as comment as long as it isn't part of the regular
expresssion. To define a  regular expression starting with two slashes (at
least) the first slash can be escaped or double quoted. (E.g., <em >"//".*</em>
defines <strong >C++</strong> comment to end-of-line).
<p>
Regular expressions end at the first blank character (to add a blank character,
e.g., a space character, to a regular expression, prefix it by a backslash or
put it in a double-quoted string).
<p>
Actions may be associated with regular expressions.  At a match the action
that is associated with the regular expression is executed, after which
scanning continues when the lexical scanning function (e.g., <em >lex</em>) is
called again. Actions are not required, and regular expressions can be defined
without any actions at all. If such action-less regular expressions are
matched then the match is performed silently, after which processing
continues.
<p>
<strong >Flexc++</strong> tries to match as many characters of the input file as possible (i.e.,
it uses `greedy matching'). Non-greedy matching is accomplished by a
combination of a scanner and parser and/or by using the `lookahead' operator
(<em >/</em>).
<p>
The following regular expression `building blocks' are available. More complex
regular expressions are created by combining them:
<p>
<dl>
<dt ><strong><em >x</em></strong></dt>
    the character `x';
<dt ><strong><em >.</em></strong></dt>
    any character (byte) except newline;
<dt ><strong><em >[xyz]</em></strong></dt>
   a character class; in this case, the pattern matches either an `x',
    a `y', or a `z'. See also the paragraph about character classes below;
<dt ><strong><em >[abj-oZ]</em></strong></dt>
   a character class containing a range; matches an `a', a `b', any
    letter from `j' through `o', or a `Z'. See also the paragraph about
    character classes below;
<dt ><strong><em >[^A-Z]</em></strong></dt> a negated character class, i.e., any character except
    for those in the class.  In this example, any non-capital character. See
    also the paragraph about character classes below; 
<dt ><strong><em >"[xyz]\"foo"</em></strong></dt>
    text between double quotes matches the literal string: <em >[xyz]"foo</em>;
<dt ><strong>R"([xyz]\"foo)"</strong></dt>
    the literal string  `<em >[xyz]\"foo</em>' (using a raw string literal);
<dt ><strong><em >\X</em></strong></dt>
   if X is `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C
    interpretation of `\x' is matched. Otherwise, a literal `X' is matched
    (this is used to escape operators such as `*');
<dt ><strong><em >\0</em></strong></dt>
    a NUL character (ASCII code 0);
<dt ><strong><em >\123</em></strong></dt>
    the character with octal value 123;
<dt ><strong><em >\x2a</em></strong></dt>
    the character with hexadecimal value 2a;
<dt ><strong><em >(r)</em></strong></dt>
   the regular expression `r'; parentheses are used to override
    precedence (see below);
<dt ><strong><em >{name}</em></strong></dt>
   the expansion of the `name' definition;
<dt ><strong><em >r*</em></strong></dt> 
   zero or more regular expressions `r'. This also matches the empty
    string;
<dt ><strong><em >r+</em></strong></dt>
   one or more regular expressions `r';
<dt ><strong><em >r?</em></strong></dt>
   zero or one regular expression `r'.  This also matches the empty
    string;
<dt ><strong><em >rs</em></strong></dt>
   the regular expression `r' followed by the regular expression `s';
    called concatenation;
<dt ><strong><em >r{m, n}</em></strong></dt> 
   regular expression `r' at least m, but at most n times (<em >0 &lt;= m
    &lt;= n</em>).  A regular expression to which <em >{0, 0}</em> is appended
    is ignored, and a warning message is shown.
<dt ><strong><em >r{m,}</em></strong></dt>
   regular expression `r' m or more times (<em >0 &lt;= m</em>);
<dt ><strong><em >r{m}</em></strong></dt>
   regular expression `r' exactly m times (<em >0 &lt;= m</em>).  A regular expression
    to which <em >{0}</em> is appended is ignored, and a warning message is shown; 
<dt ><strong><em >r|s</em></strong></dt>
   either regular expression `r' or regular expression `s';
<dt ><strong><em >r/s</em></strong></dt>
   regular expression `r' if it is followed by regular expression
    `s'. The text matched by `s' is included when determining whether this
    rule results in the longest match, but `s' is then returned to the input
    before the rule's action (if defined) is executed.
<p>
If <strong >flexc++</strong> detects patterns potentially not matching any text it generates 
    warnings like this:
        <pre>

    [Warning] input, line 7: null-matching regular expression
        
</pre>

    By placing the comment
        <pre>

    //%nowarn
        
</pre>

   on the line just before a regular expression that potentially does not
    match any text, the warning for that regular expression is suppressed;
<p>
<dt ><strong><em >^r</em></strong></dt>
   a regular expression `r' at the beginning of a line or file;
<dt ><strong><em >r$</em></strong></dt>
   a regular expression `r', occurring  at the end of a line. This
    pattern is identical to `r/\n';
<dt ><strong><em >&lt;s&gt;r</em></strong></dt>
   a regular expression `r' in start condition `s';
<dt ><strong><em >&lt;s1,s2,s3&gt;r</em></strong></dt>
   a regular expression `r' in start conditions s1, s2, or s3;
<dt ><strong><em >&lt;*&gt;r</em></strong></dt>
   a regular expression `r' in all start conditions;
<dt ><strong><em >&lt;</em><em >&lt;EOF&gt;</em><em >&gt;</em></strong></dt>
   an end-of-file;
<dt ><strong><em >&lt;s1,s2&gt;&lt;</em><em >&lt;EOF&gt;</em><em >&gt;</em></strong></dt>
   an end-of-file when in start conditions s1 or s2 .
</dl>
<p>
<strong >Character classes</strong>
<p>
Inside a character class all regular expression operators lose their special
meanings, except for the escape character (<em >\</em>), the character range
operator <em >-</em>, the end of character class operator <em >]</em>, and, at the
beginning of the class, <em >^</em>. All ordinary escape sequences are supported,
all other escaped characters are interpreted as literal characters (e.g.,
<em >\c</em> is a literal <em >c</em>).
<p>
To add a closing bracket to a character class use <em >[]</em> or <em >\]</em>. To add a
closing bracket to a negated character class use <em >[^]</em> (or use <em >[^</em>
followed by <em >\]</em> somewhere within the character class). Minus characters are
used to define character ranges (e.g., <em >[a-d]</em>, defining <em >[abcd]</em>) except
in the following cases, where <strong >flexc++</strong> recognizes a literal minus character:
    <em >[-</em>, or <em >[^-</em> (a minus at the very beginning of a character class); 
    <em >-]</em> (a minus at the very end of a character class); 
    or <em >\-</em> (an escaped minus character))
 Once a character class has started, all
subsequent character (ranges) are added to the set, until the final closing
bracket (<em >]</em>) has been reached.
<p>
<strong >Operator precedence</strong>
<p>
The regular expressions listed above are grouped according to precedence, from
highest precedence at the top to lowest at the bottom. From lowest to highest
precedence, the operators are:
        <ul>
        <li> <em >|</em>: the or-operator at the end of a line (instead of an action)
indicates that this expression's action is identical to the action of the next
rule. 
        <li> <em >/</em>: the look-ahead operator;
        <li> <em >|</em>: the or-operator withn a regular expression;
        <li> <em >CHAR</em>: individual elements of the regular expression: characters,
strings, quoted characters, escaped characters, character sets etc. are all
considered <em >CHAR</em> elements. Multiple <em >CHAR</em> elements can be combined by
enclosing them in parentheses (e.g., <em >(abc)+</em> indicates sequences of <em >abc</em>
characters, like <em >abcabcabc</em>);
        <li> <em >*, ?, +, {</em>: multipliers:<br/>
            <em >?</em>: zero or one occurrence  of the previous element;<br/>
            <em >+</em>: one or more repetitions of the previous element;<br/>
            <em >*</em>: zero or more repetitions of the previous element;<br/>
            <em >{...}</em>: interval specification: a specified number of
                repetitions of the previous element (see above for specific
                forms of the interval specification)
        <li> <em >{+}, {-}</em>: set operators (<em >{+}</em> computing the union of two sets,
                <em >{-}</em> computing the difference of the left-hand side set
                minus the elements in the right-hand side set);
        </ul>
<p>
The lex standard defines concatenation as having a higher precedence than the
interval expression. This is different from many other regular expression
engines, and <strong >flexc++</strong> follows these latter engines, giving all `multiplication
operators' equal priority.
<p>
Name expansion has the same precedence as grouping (using parentheses to
influence the precedence of the other operators in the regular expression).
Since the name expansion is treated as a group in <strong >flexc++</strong>, it is not allowed to
use the lookahead operator in a name definition (a named pattern, defined in
the definition section).
<p>
<strong >Predefined sets of characters</strong>
<p>
Character classes can also contain character class expressions. These are
expressions enclosed inside <em >[:</em> and <em >:]</em> delimiters (which themselves
must appear between the <em >[</em> and <em >]</em> of the character class. Other elements
may occur inside the character class as well). The character class expressions
are:
        <pre>
     
     [:alnum:] [:alpha:] [:blank:]
     [:cntrl:] [:digit:] [:graph:]
     [:lower:] [:print:] [:punct:]
     [:space:] [:upper:] [:xdigit:]
        
</pre>

<p>
Character class expressions designate a set of characters equivalent to
the corresponding standard <strong >C</strong> isXXX function. For example, <em >[:alnum:]</em>
designates those characters for which <em >isalnum</em> returns true - i.e., any
alphabetic or numeric character.  For example, the following character classes
are all equivalent:
        <pre>
 
    [[:alnum:]]
    [[:alpha:][:digit:]]
    [[:alpha:][0-9]]
    [a-zA-Z0-9]
        
</pre>

<p>
A negated character class such as the example <em >[^A-Z]</em> above will match a
newline unless <em >\n</em> (or an equivalent escape sequence) is one of the
characters explicitly present in the negated character class (e.g.,
<em >[^A-Z\n]</em>). This differs from the way many other regular expression tools
treat negated character classes, but unfortunately the inconsistency is
historically entrenched. Matching newlines means that a pattern like <em >[^"]*</em>
can match the entire input unless there's another quote in the input.
<p>
<strong >Flexc++</strong> allows negation of character class expressions by prepending <em >^</em> to
the POSIX character class name.
        <pre>
                
    [:^alnum:] [:^alpha:] [:^blank:]
    [:^cntrl:] [:^digit:] [:^graph:]
    [:^lower:] [:^print:] [:^punct:]
    [:^space:] [:^upper:] [:^xdigit:]
        
</pre>
      
<p>
<strong >Combining character sets</strong>
<p>
The <em >{-}</em> operator computes the difference of two character classes. For
example, <em >[a-c]{-}[b-z]</em> represents all the characters in the class
<em >[a-c]</em> that are not in the class <em >[b-z]</em> (which in this case, is just the
single character <em >a</em>). The <em >{-}</em> operator is left associative, so
<em >[abc]{-}[b]{-}[c]</em> is the same as <em >[a]</em>.
<p>
The <em >{+}</em> operator computes the union of two character classes. For example,
<em >[a-z]{+}[0-9]</em> is the same as <em >[a-z0-9]</em>. This operator is useful when
preceded by the result of a difference operation, as in,
<em >[[:alpha:]]{-}[[:lower:]]{+}[q]</em>, which is equivalent to <em >[A-Zq]</em> in the
<strong >C</strong> locale.
<p>
<strong >Trailing context</strong>
<p>
A rule can have at most one instance of trailing context (the <em >/</em> operator
or the <em >$</em> operator). The start condition, <em >^</em>, and <em >&lt;&lt;EOF&gt;&gt;</em> patterns
can only occur at the beginning of a pattern, and cannot be surrounded by
parentheses. The characters <em >^</em> and <em >$</em> only have their special properties
at, respectively, the beginning and end of regular expressions. In all other
cases they are treated as a normal characters.
<p>
<h2 >8. SPECIFICATION EXAMPLE</h2>
<p>
<pre>

%option debug

%x comment

NAME    [[:alpha:]][_[:alnum:]]*

%%

"//".*          // ignore

"/*"            begin(StartCondition_::comment);

&lt;comment&gt;.|\n   // ignore
&lt;comment&gt;"*/"   begin(StartCondition_::INITIAL);

^a              return 1;
a               return 2;
a$              return 3;
{NAME}          return 4;

.|\n            // ignore
        
</pre>

<p>
)
<p>
<h2 >FILES</h2>
<p>
<strong >Flexc++</strong>'s default skeleton files are in <em >/usr/share/flexc++</em>.<br/>
    By default, <strong >flexc++</strong> generates the following files:
        <ul>
        <li> <em >Scanner.h</em>: the header file containing the scanner class's
            interface. 
        <li> <em >Scannerbase.h</em>: the header file containing the interface of the 
            scanner class's base class.
        <li> <em >Scanner.ih</em>: the internal header file that is meant to be included
            by the scanner class's source files (e.g., it is included by
            <em >lex.cc</em>, see the next item's file), and that should contain all
            declarations required for compiling the scanner class's sources.
        <li> <em >lex.cc</em>: the source file implementing the scanner class member
            function <em >lex</em> (and support functions), performing the lexical
            scan.
    </ul>
<p>
<h2 >SEE ALSO</h2>
<p>
<strong >flexc++</strong>(1), <strong >flexc++api</strong>(3)
<p>
<h2 >BUGS</h2>
<p>
<ul>
    <li> The priority of interval expressions (<em >{...}</em>) equals the priority
of other multiplicative operators (like <em >*</em>).

    </ul>
<p>

<h2 >COPYRIGHT</h2>
    This is free software, distributed under the terms of the 
    GNU General Public License (GPL).
<p>
<h2 >AUTHOR</h2>
    Frank B. Brokken (<strong >f.b.brokken@rug.nl</strong>),<br/>
    Jean-Paul van Oosten (<strong >j.p.van.oosten@rug.nl</strong>),<br/>
    Richard Berendsen (<strong >richardberendsen@xs4all.nl</strong>) (until 2010).<br/>
<p>
</body>
</html>
