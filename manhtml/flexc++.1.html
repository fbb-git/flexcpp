<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>flexc++(1)</title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr/>
<h1 id="title">flexc++(1)</h1>
<h2 id="author">flexc++ scanner generator<br/>(flexc++.2.07.00.tar.gz)</h2>
<h2 id="date">2008-2018</h2>


<p>

<h2 >NAME</h2>flexc++ - Generate a C++ scanner class and parsing function
<p>

<h2 >SYNOPSIS</h2>
       <strong >flexc++</strong> [options] <em >rules-file</em>
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Flexc++</strong>(1) was designed after <strong >flex</strong>(1) and <strong >flex++</strong>(1). Like these
latter two programs <strong >flexc++</strong> generates code performing pattern-matching on text,
possibly executing actions when certain <em >regular expressions</em> are
recognized.
<p>
<strong >Flexc++</strong>, contrary to <strong >flex</strong> and <strong >flex++</strong>, generates code that is
explicitly intended for use by <strong >C++</strong> programs. The well-known <strong >flex</strong>(1)
program generates <strong >C</strong> source-code and <strong >flex++</strong>(1) merely offers a
<strong >C++</strong>-like shell around the <em >yylex</em> function generated by <strong >flex</strong>(1) and
hardly supports present-day ideas about <strong >C++</strong> software development.
<p>
Contrary to this, <strong >flexc++</strong> creates a <strong >C++</strong> class offering a predefined
member function <strong >lex</strong> matching input against regular expressions and
possibly executing <strong >C++</strong> code once regular expressions were matched. The
code generated by <strong >flexc++</strong> is pure <strong >C++</strong>, allowing its users to apply all
of the features offered by that language.
<p>
Not every aspect of <strong >flexc++</strong> is covered by the man-pages. In addition to
what's summarized by the man-pages the <strong >flexc++</strong> manual offers a chapter covering
pre-loading of input lines (allowing you to, e.g, display lines in which
errors are observed even though not all of the line's tokens have already been
scanned), as well as a chapter covering technical documentation about the
inner working of <strong >flexc++</strong>.
<p>
From version 0.92.00 Until version 1.07.00 <strong >flexc++</strong> offered one big manual
page. The advantage of that being that you never had to look for which manual
page contained which information. At the same time, <strong >flexc++</strong>'s man-page grew into
a huge man-page, in which it was hard to find your way. Starting with release
1.08.00 we reverted back to using multiple man-pages. The following index
relates manual pages to their specific contents:
<p>
<strong >This man-page</strong>
<p>
This man-page offers the following sections:
<p>
<ul>
    <li> <strong >1. QUICK START</strong>: a quick start overview about how to use <strong >flexc++</strong>;
    <li> <strong >2. QUICK START: FLEXC++ and BISONC++</strong>: a quick start overview
        about how to use <strong >flexc++</strong> in combination with <strong >bisonc++</strong>(1);
    <li> <strong >3. GENERATED FILES</strong>: files generated by <strong >flexc++</strong> and their purposes
    <li> <strong >4. OPTIONS</strong>: options available for <strong >flexc++</strong>.
    </ul>
<p>
The <strong >flexc++api</strong>(3) man-page:
<p>
This man-page describes the classes generated by <strong >flexc++</strong>, describing <strong >flexc++</strong>'s
actions from the programmer's point of view.
<p>
<ul>
    <li> <strong >1. INTERACTIVE SCANNERS</strong>: how to create an interactive scanner
<p>
<li> <strong >2. THE CLASS INTERFACE: SCANNER.H</strong>: Constructors and members
        of the scanner class generated by <strong >flexc++</strong> 
    <li> <strong >3. NAMING CONVENTION</strong>: symbols defined by <strong >flexc++</strong> in the scanner
        class. 
    <li> <strong >4. CONSTRUCTORS</strong>: constructors defined in the scanner class.
    <li> <strong >5. PUBLIC MEMBER FUNCTION</strong>: public member declared in the scanner
        class.
    <li> <strong >6. PRIVATE MEMBER FUNCTIONS</strong>: private members declared in the
        scanner class.
    <li> <strong >7. SCANNER CLASS HEADER EXAMPLE</strong>: an example of a generated
        scanner class header
<p>
<li> <strong >8. THE SCANNER BASE CLASS</strong>: the scanner class is derived from a
        base class. The base class is described in this section
    <li> <strong >9. PUBLIC ENUMS AND -TYPES</strong>: enums and types declared by the
        base class
    <li> <strong >10. PROTECTED ENUMS AND -TYPES</strong>: enumerations and types used by
        the scanner and scanner base classes
    <li> <strong >11. NO PUBLIC CONSTRUCTORS</strong>: the scanner base class does not
        offer public constructors.
    <li> <strong >12. PUBLIC MEMBER FUNCTIONS</strong>: several members defined by the
        scanner base class have public access rights.
    <li> <strong >13. PROTECTED CONSTRUCTORS</strong>: the base class can be constructed by
        a derived class. Usually this is the scanner class generated by <strong >flexc++</strong>.
    <li> <strong >14. PROTECTED MEMBER FUNCTIONS</strong>: this section covers the base
        class member functions that can only be used by scanner class or
        scanner base class members
    <li> <strong >15. PROTECTED DATA MEMBERS</strong>: this section covers the base class
        data members that can only be used by scanner class or scanner base
        class members
    <li> <strong >16. FLEX++ TO FLEXC++ MEMBERS</strong>: a short overview of frequently
        used <strong >flex</strong>(1) members that received different names in <strong >flexc++</strong>.
<p>
<li> <strong >17. THE CLASS INPUT</strong>: the scanner's job is completely decoupled
        from the actual input stream. The class <em >Input</em>, nested within the
        scanner base class handles the communication with the input
        streams. The  class <em >Input</em>, is described in this section.
    <li> <strong >18. INPUT CONSTRUCTORS</strong>: the class <em >Input</em> can easily be
        replaced by another class. The constructor-requirements are described
        in this section.
    <li> <strong >19. REQUIRED PUBLIC MEMBER FUNCTIONS</strong>: this section covers the
        required public members of a self-made <em >Input</em> class
    </ul>
<p>
The <strong >flexc++input</strong>(7) man-page:
<p>
This man-page describes how <strong >flexc++</strong>'s input <strong >s</strong> should be organized. It
contains the following sections:
<p>
<ul>
    <li> <strong >1. SPECIFICATION FILE(S)</strong>: the format and contents of <strong >flexc++</strong> input
        files, specifying the Scanner's characteristics
    <li> <strong >2. FILE SWITCHING</strong>: how to switch to another input specification
        file
    <li> <strong >3. DIRECTIVES</strong>: directives that can be used in input
        specification files
    <li> <strong >4. MINI SCANNERS</strong>: how to declare mini-scanners
    <li> <strong >5. DEFINITIONS</strong>: how to define symbolic names for regular
        expressions
    <li> <strong >6. %% SEPARATOR</strong>: the separator between the input specification
        sections 
    <li> <strong >7. REGULAR EXPRESSIONS</strong>: regular expressions supported by <strong >flexc++</strong>
    <li> <strong >8. SPECIFICATION EXAMPLE</strong>: an example of a specification file
    </ul>
<p>
    <h2 >1. QUICK START</h2>
<p>
A bare-bones, no-frills scanner is generated as follows:
<p>
<ul>
    <li> Create a file <em >lexer</em> defining the regular expressions to
recognize, and the tokens to return. Use token values exceeding 0xff if plain
ascii character values can also be used as token values. Example (assume
capitalized words are token-symbols defined in an enum defined by the scanner
class):
        <pre>

%%
[ \t\n]+                            // skip white space chars.
[0-9]+                              return NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return IDENTIFIER;
.                                   return matched()[0];
        
</pre>

<p>
<li> Execute:
        <pre>

    flexc++ lexer
        
</pre>

    This generates four files</ul>: <em >Scanner.h, Scanner.ih, Scannerbase.h</em>, and
<em >lex.cc</em> 
<p>
<li> Edit <em >Scanner.h</em>, add the enum defining the token-symbols in
(usually) the public section of the class <em >Scanner</em>. E.g.,
        <pre>

class Scanner: public ScannerBase
{
    public:
        enum Tokens
        {
            IDENTIFIER = 0x100,
            NUMBER
        };
    // ... (etc, as generated by flexc++)
        
</pre>

<p>
<li> Create a file defining <em >int main</em>, e.g.:
        <pre>

#include &lt;iostream&gt;
#include "Scanner.h"

using namespace std;

int main()
{
    Scanner scanner;        // define a Scanner object

    while (int token = scanner.lex())   // get all tokens
    {
        string const &amp;text = scanner.matched();
        switch (token)
        {
            case Scanner::IDENTIFIER:
                cout &lt;&lt; "identifier: " &lt;&lt; text &lt;&lt; '\n';
            break;

            case Scanner::NUMBER:
                cout &lt;&lt; "number: " &lt;&lt; text &lt;&lt; '\n';
            break;

            default:
                cout &lt;&lt; "char. token: `" &lt;&lt; text &lt;&lt; "'\n";
            break;
        }
    }
}
        
</pre>

    <li> Compile all <em >.cc</em> files:
        <pre>

    g++ *.cc
        
</pre>

<p>
<li> To `tokenize' <em >main.cc</em>, execute:
        <pre>

    a.out &lt; main.cc
        
</pre>

    )
<p>
<h2 >2. QUICK START: FLEXC++ and BISONC++</h2>
<p>
To interface <strong >flexc++</strong> to the <strong >bisonc++</strong>(1) parser generator proceed as follows:
    <ul>
    <li> Specify a grammar that can be processed by <strong >bisonc++</strong>(1). Assuming
that the scanner and parser are developed in, respectively, the
sub-directories <em >scanner</em> and <em >parser</em>, then a simple grammar
specification that can be used with the scanner developed in the previous
section is (e.g., write the file <em >./parser/grammar</em>):
        <pre>

%scanner                ../scanner/Scanner.h

%token IDENTIFIER NUMBER CHAR

%%

startrule:
    startrule tokenshow
|
    tokenshow
;

tokenshow:
    token
    {
        std::cout &lt;&lt; "matched: " &lt;&lt; d_scanner.matched() &lt;&lt; '\n';
    }
;

token:
    IDENTIFIER
|
    NUMBER
|
    CHAR
;
    
</pre>

    <li> Now that the tokens have been identified, change to the (mentioned)
<em >./scanner</em> directory and write a scanner specification file
<em >lexer</em>. E.g., 
    <pre>

%%

[ \t\n]+                            // skip white space chars.
[0-9]+                              return Parser::NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return Parser::IDENTIFIER;
.                                   return Parser::CHAR;
    
</pre>

    This causes the scanner to  return <em >Parser</em> tokens to the generated
parser. 
    <li> Execute:
        <pre>

    flexc++ lexer
        
</pre>

    This generates four files</ul>: <em >Scanner.h, Scanner.ih, Scannerbase.h</em>, and
<em >lex.cc</em> 
<p>
<li> Add the line
    <pre>

#include "../parser/Parserbase.h"
    
</pre>

    to the file <em >scanner/Scanner.ih</em>
<p>
<li> Change back to the <em >./parser</em> directory and execute:
    <pre>

bisonc++ grammar
    
</pre>

    This generates four files): <em >parse.cc, Parserbase.h, Parser.h,</em> and
<em >Parser.ih</em> 
<p>
<li> Return to <em >./parser's</em> parent directory and write a simple <em >main</em>
function in the file <em >main.cc</em>. E.g., 
    <pre>

#include "parser/Parser.h"

int main(int argc, char **argv)
{
    Parser parser;

    parser.parse();
}
    
</pre>

<p>
<li> Compile all sources:
    <pre>

g++ *.cc */*.cc
    
</pre>

<p>
<li> Execute the program, providing it some source file to be processed:
    <pre>

a.out &lt; main.cc
    
</pre>

        )
<p>
<h2 >3. GENERATED FILES</h2>
<p>
<strong >Flexc++</strong> generates four files from a well-formed input file:
    <ul>
<p>
<li> A file containing the implementation of the <em >lex</em> member function
and its support functions. By default this file is named <em >lex.cc</em>.
<p>
<li> A file containing the scanner's class interface. By default this file
is named <em >Scanner.h</em>. The scanner class itself is generated once and is
thereafter `owned' by the programmer, who may change it <em >ad-lib</em>. Newly
added members (data members, function members) will survive future <strong >flexc++</strong> runs
as <strong >flexc++</strong> will never rewrite an existing scanner class interface file, unless
explicitly ordered to do so. 
<p>
<li> A file containing the interface of the scanner class's <em >base
class</em>. The scanner class is publicly derived from this base class. It is used
to minimize the size of the scanner interface itself. The scanner base class
is `owned' by <strong >flexc++</strong> and should never be hand-modified. By
default the scanner's base class is provided in the file
<em >Scannerbase.h</em>. At each new <strong >flexc++</strong> run this file is rewritten unless <strong >flexc++</strong>
is explicitly ordered <em >not</em> to do so.
<p>
<li> A file containing the <em >implementation header</em>. This file should
contain includes and declarations that are only required when compiling the
members of the scanner class. By default this file is named
<em >Scanner.ih</em>. This file, like the file containing the scanner class's
interface is never rewritten by <strong >flexc++</strong> unless <strong >flexc++</strong> is explicitly ordered to do
so.
    </ul>
<p>
<h2 >4. OPTIONS</h2>
<p>
    Where available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.  Options
affecting the class header or implementation header file are ignored if these
files already exist. Options accepting a `filename' do not accept path names,
i.e., they cannot contain directory separators (<em >/</em>); options accepting a
'pathname' may contain directory separators.
<p>
Some options may generate errors. This happens when an option conflicts with
the contents of an existing file which <strong >flexc++</strong> cannot modify (e.g., a scanner
class header file exists, but doesn't define a name space, but a
<em >--namespace</em> option was provided). To solve the error the offending option
could be omitted, the existing file could be removed, or the existing file
could be hand-edited according to the option's specification. Note that <strong >flexc++</strong>
currently does not handle the opposite error condition: if a previously used
option is omitted, then <strong >flexc++</strong> does not detect the inconsistency. In those
cases you may encounter compilation errors.
<p>
<ul>
    <li> <strong >--baseclass-header</strong>=<em >filename</em> (<strong >-b</strong>)<br/>
          Use <em >filename</em> as the name of the file to contain the scanner
           class's base class. Defaults to the name of the scanner class plus
           <em >base.h</em>
<p>
It is an error if this option is used and an already
            existing scanner-class header file does not include
            <em >`filename'</em>. 
<p>
<li> <strong >--baseclass-skeleton</strong>=<em >pathname</em> (<strong >-C</strong>)<br/> 
           Use <em >pathname</em> as the path to the file containing the skeleton of
            the scanner class's base class. Its filename defaults to
            <em >flexc++base.h</em>.
<p>
<li> <strong >--case-insensitive</strong><br/>
           Use this option to generate a scanner <em >case insensitively</em>
            matching regular expressions. All regular expressions specified in
            <strong >flexc++</strong>'s input file are interpreted case insensitively and the
            resulting scanner object will case insensitively interpret its
            input. 
<p>
When this option is specified the resulting scanner does not
            distinguish between the following rules:
           <pre>

        First       // initial F is transformed to f
        first
        FIRST       // all capitals are transformed to lower case chars
                
</pre>

           With a case-insensitive scanner only the first rule can be matched,
            and <strong >flexc++</strong> will issue warnings for the second and third rule about
            rules that cannot be matched.
<p>
Input processed by a case-insensitive scanner is also handled case
            insensitively. The above mentioned <em >First</em> rule is matched for
            all of the following input words: <em >first First FIRST firST</em>. 
<p>
Although the matching process proceeds case insensitively, the
            matched text (as returned by the scanner's <em >matched()</em> member)
            always contains the original, unmodified text. So, with the above
            input <em >matched()</em> returns, respectively <em >first, First, FIRST</em>
            and <em >firST</em>, while matching the rule <em >First</em>.
<p>
<li> <strong >--class-header</strong>=<em >filename</em> (<strong >-c</strong>)<br/>
           Use <em >filename</em> as the name of the file to contain the scanner
            class. Defaults to the name of the scanner class plus the suffix
            <em >.h</em>
<p>
<li> <strong >--class-name</strong>=<em >className</em><br/>
           Use <em >className</em> (rather than <em >Scanner</em>) as the name of the
            scanner class. Unless overridden by other options generated files
            will be given the (transformed to lower case) <em >className*</em> name
            instead of <em >scanner</em>*.
<p>
It is an error if this option is used and an already
            existing scanner-class header file does not define <em >class
            `className'</em>
<p>
<li> <strong >--class-skeleton</strong>=<em >pathname</em> (<strong >-C</strong>)<br/>
           Use <em >pathname</em> as the path to the file containing the skeleton of
            the scanner class. Its filename defaults to <em >flexc++.h</em>.
<p>
<li> <strong >--construction</strong> (<strong >-K</strong>)<br/>
           Write details about the lexical scanner to the file
            <em >`rules-file'.output</em>. Details cover the used character ranges,
            information about the regexes, the raw NFA states, and the final
            DFAs.
<p>
<li> <strong >--debug</strong> (<strong >-d</strong>)<br/> 
           Provide <em >lex</em> and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the <em >setDebug(bool
            on-off)</em> member. Note that <em >#ifdef DEBUG</em> macros are not used
            anymore. By rerunning <strong >flexc++</strong> without the <strong >--debug</strong> option an
            equivalent scanner is generated not containing the debugging
            code. This option does not provide debug information about <strong >flexc++</strong>
            itself. For that use the options <em >--own-parser</em> and/or
            <em >--own-tokens</em> (see below). 
<p>
<li> <strong >--filenames</strong>=<em >genericName</em> (<strong >-f</strong>)<br/>
           Generic name of generated files (header files, not the
            <em >lex</em>-function source file, see the <em >--lex-source</em> option for
            that). By default the header file names will be equal to the name
            of the generated class.
<p>
<li> <strong >--help</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--implementation-header</strong>=<em >filename</em> (<strong >-i</strong>)<br/> 
           Use <em >filename</em> as the name of the file to contain the
            implementation header. Defaults to the name of the generated
            scanner class plus the suffix <em >.ih</em>. The implementation header
            should contain all directives and declarations <em >only</em> used by
            the implementations of the scanner's member functions. It is the
            only header file that is included by the source file containing
            <strong >lex()</strong>'s implementation.  User defined implementation of other
            class members may use the same convention, thus concentrating all
            directives and declarations that are required for the compilation
            of other source files belonging to the scanner class in one header
            file.
<p>
It is an error if this option is used and an already
            <em >'filename'</em> file does not include the scanner class header
            file.
<p>
<li> <strong >--implementation-skeleton</strong>=<em >pathname</em> (<strong >-I</strong>)<br/>
           Use <em >pathname</em> as the path to the file containing the skeleton of
            the implementation header. Its filename defaults to
            <em >flexc++.ih</em>.
<p>
<li> <strong >--lex-skeleton</strong>=<em >pathname</em> (<strong >-L</strong>)<br/>
           Use <em >pathname</em> as the path to the file containing the
            <em >lex()</em> member function's skeleton. Its filename defaults to
            <em >flexc++.cc</em>.
<p>
<li> <strong >--lex-function-name</strong>=<em >funname</em><br/>
           Use <em >funname</em> rather than <em >lex</em> as the name of the member
            function performing the lexical scanning.
<p>
<li> <strong >--lex-source</strong>=<em >filename</em> (<strong >-l</strong>)<br/>
           Define <em >filename</em> as the name of the source file to contain the
            scanner member function <em >lex</em>. Defaults to <em >lex.cc</em>.
<p>
<li> <strong >--matched-rules</strong> (<strong >-'R'</strong>)<br/>
           The generated scanner will write the numbers of matched rules to 
            the standard output. It is implied by the <em >--debug</em> option.
            Displaying the matched rules can be suppressed by calling the
            generated  scanner's member <em >setDebug(false)</em> (or, of course, by
            re-generating the scanner without using specifying 
            <em >--matched-rules</em>).
<p>
<li> <strong >--max-depth</strong>=<em >depth</em> (<strong >-m</strong>)<br/>
           Set the maximum inclusion depth of the lexical scanner's
            specification files to <em >depth</em>. By default the maximum depth is
            set to 10. When more than <em >depth</em> specification files are used
            the scanner throws a <em >Max stream stack size exceeded</em>
            <em >std::length_error</em> exception. 
<p>
<li> <strong >--namespace</strong>=<em >identifier</em> <br/>
           Define the scanner class in the namespace <em >identifier</em>. By default
            no namespace is used. If this options is used the
            implementation header is provided with a commented out <em >using
            namespace</em> declaration for the requested namespace.  In addition,
            the scanner and scanner base class header files also use the 
            specified namespace to define their include guard directives.
<p>
It is an error if this option is used and an already
            scanner-class header file does not define <em >namespace
            identifier</em>. 
<p>
<li> <strong >--no-baseclass-header</strong><br/>
           Do not write the file containing the scanner's base class interface
            even if it doesn't yet exist. By default the file containing the
            scanner's base class interface is (re)written each time <strong >flexc++</strong> is
            called.
<p>
<li> <strong >--no-lines</strong><br/> 
           Do not put <strong >#line</strong> preprocessor directives in the file containing
            the scanner's <em >lex</em> function. By default <em >#line</em> directives
            are entered at the beginning of the action statements in the
            generated <em >lex.cc</em> file, allowing the compiler and debuggers
            to associate errors with lines in your grammar specification
            file, rather than with the source file containing the <em >lex</em>
            function itself.
<p>
<li> <strong >--no-lex-source</strong><br/>
           Do not write the file containing the scanner's predefined scanner
            member functions, even if that file doesn't yet exist. By default
            the file containing the scanner's <em >lex</em> member function is
            (re)written each time <strong >flexc++</strong> is called. This option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
<p>
<li> <strong >--own-parser</strong> (<strong >-P</strong>)<br/> 
           The actions performed by <strong >flexc++</strong>'s own parser are written to the
            standard output stream.
<p>
This option does <em >not</em> result in the generated program optionally
            displaying the actions of its <em >lex</em> function. If that is what
            you want, use the <em >--debug</em> option.
<p>
<li> <strong >--own-tokens</strong> (<strong >-T</strong>)<br/> 
           The tokens returned as well as the text matched by <strong >flexc++</strong> are
            written to the standard output stream when this option is used.
<p>
This option does <em >not</em> result in the generated program displaying
            returned tokens and matched text. If that is what you want, use
            the <em >--print-tokens</em> option.
<p>
<li> <strong >--print-tokens</strong> (<strong >-t</strong>)<br/> 
           The tokens returned as well as the text matched by the
            <em >generated</em> <em >lex</em> function are displayed on the standard
            output stream, just before returning the token to <em >lex</em>'s
            caller. Displaying tokens and matched text is suppressed again
            when the <em >lex.cc</em> file is generated without using this
            option. The function showing the tokens (<em >ScannerBase::print_</em>)
            is called from <em >Scanner::printTokens</em>, which is defined in-line
            in <em >Scanner.h</em>. Calling <em >ScannerBase::print_</em>, therefore, can
            also easily be controlled by an option controlled by the program
            using the scanner object.
<p>
This option does <em >not</em> show the tokens returned and text matched
            by <strong >flexc++</strong> itself when reading its input <strong >s</strong>. If that is what
            you want, use the <em >--own-tokens</em> option.
<p>
<li> <strong >--regex-calls</strong><br/> 
           Show the function call order when parsing regular expressions (this
            option is normally not required. Its main purpose is to help
            developers understand what happens when regular expressions are
            parsed).
<p>
<li> <strong >--show-filenames</strong> (<strong >-F</strong>)<br/> 
           Write the names of the files that are generated to the 
            standard error stream.
<p>
<li> <strong >--skeleton-directory</strong>=<em >pathname</em> (<strong >-S</strong>)<br/> 
           Defines the directory containing the skeleton files. This option
            can be overridden by the specific skeleton-specifying options
            (<em >-B -C, -H,</em> and <em >-I</em>).
<p>
<li> <strong >--target-directory</strong>=<em >pathname</em> <br/> 
           Specifies the directory where generated files should be written.
            By default this is the directory where <strong >flexc++</strong> is called.
<p>
<li> <strong >--usage</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--verbose</strong>(<strong >-V</strong>)<br/> 
           The verbose option generates on the standard output stream various
            pieces of additional information, not covered by the
            <em >--construction</em> and <em >--show-filenames</em> options.
<p>
<li> <strong >--version</strong> (<strong >-v</strong>)<br/>
            Display <strong >flexc++</strong>'s version number and terminate.
    </ul>
<p>
<h2 >FILES</h2>
<p>
<strong >Flexc++</strong>'s default skeleton files are in <em >/usr/share/flexc++</em>.<br/>
    By default, <strong >flexc++</strong> generates the following files:
        <ul>
        <li> <em >Scanner.h</em>: the header file containing the scanner class's
            interface. 
        <li> <em >Scannerbase.h</em>: the header file containing the interface of the 
            scanner class's base class.
        <li> <em >Scanner.ih</em>: the internal header file that is meant to be included
            by the scanner class's source files (e.g., it is included by
            <em >lex.cc</em>, see the next item's file), and that should contain all
            declarations required for compiling the scanner class's sources.
        <li> <em >lex.cc</em>: the source file implementing the scanner class member
            function <em >lex</em> (and support functions), performing the lexical
            scan.
    </ul>
<p>
<h2 >SEE ALSO</h2>
<p>
<strong >bisonc++</strong>(1), <strong >flexc++api</strong>(3), <strong >flexc++input</strong>(7)
<p>
<h2 >BUGS</h2>
<p>
None reported
<p>
<h2 >ABOUT flexc++</h2>
<p>
<strong >Flexc++</strong> was originally started as a programming project by Jean-Paul van
Oosten and Richard Berendsen in the 2007-2008 academic year. After graduating,
Richard left the project and moved to Amsterdam. Jean-Paul remained in
Groningen, and after on-and-off activities on the project, in close
cooperation with Frank B. Brokken, Frank undertook a rewrite of the project's
code around 2010. During the development of <strong >flexc++</strong>, the lookahead-operator
handling continuously threatened the completion of the project. But in
version 2.00.00 the lookahead operator received a completely new
implementation (with a bug fix in version 2.04.00), which solved previously
encountered problems with the lookahead-operator.
<p>

<h2 >COPYRIGHT</h2>
    This is free software, distributed under the terms of the 
    GNU General Public License (GPL).
<p>
<h2 >AUTHOR</h2>
    Frank B. Brokken (<strong >f.b.brokken@rug.nl</strong>),<br/>
    Jean-Paul van Oosten (<strong >j.p.van.oosten@rug.nl</strong>),<br/>
    Richard Berendsen (<strong >richardberendsen@xs4all.nl</strong>) (until 2010).<br/>
<p>
</body>
</html>
